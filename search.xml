<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git学习随笔]]></title>
    <url>%2F2019%2F01%2F16%2Fgit-study-notes%2F</url>
    <content type="text"><![CDATA[[TOC] 记一些Git学习时的笔记供之后参考，可以从博客右侧的导航栏进行便捷浏览。 Git远程操作查看/设置远程仓库 查看远程分支引用列表：git ls-remote 54f42552f530fe64acdf71e68c5de3b8ac1b9184 HEAD54f42552f530fe64acdf71e68c5de3b8ac1b9184 refs/for/master54f42552f530fe64acdf71e68c5de3b8ac1b9184 refs/heads/master 查看本地仓库已经配置的远程仓库信息：git remote -v 查看远程仓库详细信息：git remote show [remote-name] 添加远程仓库：git remote add &lt;remote-name&gt; &lt;url&gt;添加远程仓库URL，并设置一个简写的远程仓库名称，这个名称代替整个URL。这里的remote-name可以任意命名，默认clone过来的仓库，remote-name为origin。 拉取远程仓库信息git fetch git fetch &lt;remote-name&gt;拉取某个远程远程仓库信息，例如：git remote origin，git fetch --all拉取本地仓库所有绑定的远程仓库信息。 git fetch会将该远程仓库的所有信息（本地没有的）拉取到本地仓库中，更新所有远程分支的提交引用（但不用合并代码）。 git pull git pull命令，拉取远程主机某个分支的提交更新。命令为：git pull &lt;remote-name&gt; &lt;branch-name&gt;如果本地分支设置了远程的跟踪分支（上游），那么可以直接使用git pull。git pull 会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。 Git常用撤销操作 撤销文件暂存状态: git reset HEAD &lt;file&gt; 撤销对文件的修改：git checkout -- &lt;file&gt; Git重置git reset 命令git reset命令有3种形式. git reset [-q] [&lt;tree-ish&gt;] [--] &lt;paths&gt;... git reset (--patch | -p) [&lt;tree-ish&gt;] [--] [&lt;paths&gt;...] git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [&lt;commit&gt;] 这里将1、2两种带有paths的形式称为基于路径的使用方式，将第3种带有commit的形式称为基于提交记录的使用方式。 根据这2种使用方式，在平时使用时有两种使用场景: 重置暂存区 ，撤销文件暂存。(不会移动HEAD分支指向)git reset HEAD -- paths或者直接git reset HEAD，由于reset参数默认是--mixed级别，表示将HEAD中的文件状态复制到暂存区。也就是相当于撤销了新文件的暂存，取消了git add命令的操作。这个命令执行完成后，文件的状态是被修改但未暂存（Changes not staged）。 用来将当前分支的HEAD指针移动到某个提交上这种使用方式会根据传递的选项来决定进行什么样的操作, 但都会先将分支的HEAD指针进行移动. 移动的后续操作取决于传入的是--mixed还是--soft或是--hard. --soft 仅仅是移动HEAD指针到某次提交上, 暂存区和工作区不受影响，表示仅仅撤销提交, 重置前如果有加入到暂存区的文件会依旧保留在暂存区, (表示我们希望撤销git commit) --mixed 移动HEAD指针后, 如果重置前有加入到暂存区的文件, 那么会被取消暂存, 但工作区不受影响. (表示我们希望撤销git commit以及git add) --hard 在移动HEAD指针后, 会将暂存区及工作区都重置为对应提交记录的状态上去. (撤销git commit 、git add以及工作区所有的修改) 关于git reset [–soft | –mixed | –hard] 命令操作过程: 首先git reset命令的三个选项都会将当前分支的HEAD指针进行移动. --soft 仅仅是移动指针，不会对暂存区和工作区做修改，重置后，工作区和index中依旧是之前的文件状态。 --mixed移动HEAD指针后，再将对应HEAD指向的提交记录中的文件拷贝至index中，所以此时index与HEAD中文件内容一致。可以通过命令git diff --cached &lt;path&gt;查看一下index与HEAD中的文件差异。这时候，工作区和index中的差异就是相对于HEAD中的差异，可以通过命令git diff &lt;commit&gt; &lt;path&gt;查看一下。 --hard则在移动HEAD指针后先将HEAD中对应的内容复制到index中, 同时还会将index的内容复制给工作区. https://www.git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86 Git检出检出分支 从Tag检出分支：git checkout -b [branchname] [tagname] 基于其他分支检出：git checkout -b &lt;new-branch-name&gt; &lt;base-branch-name&gt; 如果基分支是远程分支，那么检出分支会建立绑定关系（设置其为跟踪分支或上游分支）：git checkout -b [branch][remotename]/[branch] git checkout -b [branch][remotename]/[branch]可简写为：git checkout --track [remotename]/[branch] 撤销对未暂存文件的修改命令：git checkout -- &lt;file&gt; Git Tag 操作 查看tag列表：git tag 查看tag信息：git show &lt;tag-name&gt; 创建tag：git tag -a v1.4 -m &#39;my version 1.4&#39; &lt;commit-id&gt; 删除tag：git tag -d &lt;tag-name&gt; 推送tag到远程：git push origin &lt;tag-name&gt; / 推送本地所有tag：git push --tags 删除远程tag：git push origin :refs/tags/&lt;tag-name&gt;（将远程tag引用至空） https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013762144381812a168659b3dd4610b4229d81de5056cc000 Git配置git config section.key &quot;配置值&quot;，例如git config user.name &quot;Bennie Joey&quot; 配置的3个级别，-e表示编辑配置文件： git config -e当前仓库，优先级最高 git config --global -e当前用户 git config --system -e系统全局，优先级最低 git config --list列出所有 Git 当时能找到的配置。 配置别名 命令配置：git config --global alias.&lt;别名&gt; &#39;命令内容&#39;，如：git config --global alias.st &#39;status&#39; 手动配置：git config -e --global编辑配置文件，加入到”[alias]”节即可。 123456789101112131415161718ci = commitcim = commit -mco = checkoutcob = checkout -blgol = log --onelinest = statussts = status -sa = !git add . &amp;&amp; git statusau = !git add -u . &amp;&amp; git statusaa = !git add . &amp;&amp; git add -u . &amp;&amp; git statusca = commit --amend # carefulac = !git add . &amp;&amp; git commitacm = !git add . &amp;&amp; git commit -mlg = log --color --graph --pretty=format:&apos;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&apos; --abbrev-commitd = diffalias = !git config --list | grep &apos;alias\\.&apos; | sed &apos;s/alias\\.\\([^=]*\\)=\\(.*\\)/\\1\\\t =&gt; \\2/&apos; | sortbr = branchunstage = reset HEAD -- Git分支操作检出分支 分支可以从一个commit、tag、其他分支上进行基础。 创建分支，只是相当于从commit对象上建立了一个指针，然后让其内部的HEAD指针指向这个分支，就会知道当前工作区处于哪个分支上（可以将 HEAD 想象为当前分支的别名）。 远程分支操作设置本地分支的远程跟踪分支设置后可以直接在当前分支上使用git pull、git push。 从远程分支检出本地分支（会自动设置远程分支为跟踪分支），见：检出分支 修改或者本地分支的远程跟踪分支：git branch -u/--set-upstream-to origin/远程分支名xgit branch (--set-upstream-to=&lt;upstream&gt; | -u &lt;upstream&gt;) [&lt;branchname&gt;] 查看本地分支的远程跟踪分支信息：git branch -vv 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。 Git信息查看查看历史提交信息Git log命令 git log &lt;file-path&gt; 查看单个文件/目录的提交记录 git log --flow &lt;file-path&gt; 追溯文件全部历史，包括删除、重命名文件名。、 git log pretty=oneline/short/full/fuller/format:&lt;格式化&gt;，format参数如下： 选项 说明 %H 提交对象（commit）的完整哈希字串 %h 提交对象的简短哈希字串 %T 树对象（tree）的完整哈希字串 %t 树对象的简短哈希字串 %P 父对象（parent）的完整哈希字串 %p 父对象的简短哈希字串 %an 作者（author）的名字 %ae 作者的电子邮件地址 %ad 作者修订日期（可以用 –date= 选项定制格式） %ar 作者修订日期，按多久以前的方式显示 %cn 提交者（committer）的名字 %ce 提交者的电子邮件地址 %cd 提交日期 %cr 提交日期，按多久以前的方式显示 %s 提交说明 git log常用命令选项 选项 说明 -(n) 仅显示最近的 n 条提交 --since, --after 仅显示指定时间之后的提交。 --until, --before 仅显示指定时间之前的提交。 --author 仅显示指定作者相关的提交。 --committer 仅显示指定提交者相关的提交。 --grep 仅显示含指定关键字的提交 -S 仅显示添加或移除了某个关键字的提交 https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2 查看对象库信息 git show &lt;branch&gt; 命令使用底层命令 git cat-file查看对象内容 1234-t 查看对象类型。类型可以是blob, tree, commit, tag其中之一-s 显示对象大小-e exit with zero when there&apos;s no error-p 打印对象内容 git ls-files 浏览文件内容。 123456789101112-z paths are separated with NUL character-t identify the file status with tags-v use lowercase letters for &apos;assume unchanged&apos; files-f use lowercase letters for &apos;fsmonitor clean&apos; files-c, --cached 显示已被暂存的文件。-d, --deleted 显示已经被删除的文件。-m, --modified 显示被修改的文件。-o, --others show other files in the output-i, --ignored 显示被忽略的文件。-s, --stage show staged contents&apos; object name in the output-k, --killed 显示文件系统上需要被移除的文件--directory show &apos;other&apos; directories&apos; names only git rev-parse 将标签、相对名、简写或绝对名称转成实际的提交散列ID。 git rm命令 git rm &lt;file&gt; --cached 移除索引中已经暂存的文件（工作区文件依旧保留）。 git rm &lt;file&gt;移除索引和工作区的文件。（文件需要被暂存） git rm -f &lt;file&gt; -f命令 表示在删除之前已存在被加到暂存区的文件一样会被强制移除。 git diff 命令该命令用来查看文件的不同. git diff &lt;file&gt;查看工作区相对于暂存区作出的更改。（默认） git diff &lt;commit&gt; &lt;file&gt; 查看工作区与指定提交的文件差异 git diff --cached [&lt;commit&gt;] &lt;file&gt; 查看暂存区与HEAD或指定提交中的差异。 git diff &lt;commit&gt; &lt;commit&gt; 查询两次提交中的文件差异。 git diff &lt;file&gt; 表示查看工作区相对于暂存区的差异：123456789$ git diff t.txt diff --git a/t.txt b/t.txtindex 1191247..01e79c3 100644--- a/t.txt+++ b/t.txt@@ -1,2 +1,3 @@12+3]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven中的一些概念及笔记]]></title>
    <url>%2F2018%2F07%2F24%2Fconcepts-and-notes-in-maven%2F</url>
    <content type="text"><![CDATA[以前粗浅的学习过Maven的一些概念，但后来时间长了忘记了。虽然也会用，但做项目期间也经常断断续续的查找Maven相关的概念及知识，总觉得不是个事没有建立起比较整体的概念，所以这里写个笔记记录一下Maven的一些概念以及使用方面的东西，方便以后查阅。 记得以前看到过一句话，说是如果你无法向别人讲清楚一个东西，那说明你没有真正的掌握它。所以我记东西或者说写博客有个特点，会将自己做为第三者的角度去对待，一方面是为了记录下来能让自己以后一个参考，一方面也是为了想让自己和别人理解这个东西，所以文章可能写的有些唠叨，因为记录了一些在了解过程中的疑问及想法，毕竟学习的时候总有点好奇心不是。 Maven生命周期和插件在开始之前先说明一下，Maven的生命周期和插件是两个东西，Maven的生命周期实际上不负责任何实际的东西，实际执行生命周期的阶段时是依靠绑定其绑定到的插件目标上来完成的。可以理解为，生命周期中定义了一些阶段行为，执行阶段行为时，会去寻找其绑定插件对应的目标来完成指定的操作。光说概念还是有点抽象，下面来详细说一下生命周期和插件是个什么东东以及它们如何完成相互配合的。 生命周期在生命周期中首先要明白两个概念： 生命周期：Maven拥有三套相互独立的生命周期，它们分别为clean、default和site。 生命周期中的阶段：每个生命周期包含一些阶段（phase），这些阶段是有顺序的，并且后面的阶段依赖于前面的阶段，用户和Maven最直接的交互方式就是调用这些生命周期阶段。(这句话如何理解，下文会说) 那这时候我们就想要知道，每个生命周期中都有哪些阶段？都负责些什么操作。 在Maven的官网文档，我们可以查阅Maven各生命周期包含的阶段：https://maven.apache.org/ref/3.5.3/maven-core/lifecycles.html ，还可以查阅这里了解一下各阶段的功能介绍：https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Lifecycle_Reference 这里以clean生命周期为例，可以看到它包含的阶段有pre-clean、clean和post-clean。 12345678910&lt;phases&gt; &lt;phase&gt;pre-clean&lt;/phase&gt; &lt;phase&gt;clean&lt;/phase&gt; &lt;phase&gt;post-clean&lt;/phase&gt;&lt;/phases&gt;&lt;default-phases&gt; &lt;clean&gt; org.apache.maven.plugins:maven-clean-plugin:2.5:clean &lt;/clean&gt;&lt;/default-phases&gt; 下面的default-phases中将clean生命周期中的clean阶段绑定到了插件org.apache.maven.plugins:maven-clean-plugin:2.5的clean目标上。那这个意思就是说，生命周期中的某个具体的阶段可以绑定到插件的某个具体的目标上。 同样，我们可以再看看site生命周期中与插件的绑定关系。 1234567891011121314&lt;phases&gt; &lt;phase&gt;pre-site&lt;/phase&gt; &lt;phase&gt;site&lt;/phase&gt; &lt;phase&gt;post-site&lt;/phase&gt; &lt;phase&gt;site-deploy&lt;/phase&gt;&lt;/phases&gt;&lt;default-phases&gt; &lt;site&gt; org.apache.maven.plugins:maven-site-plugin:3.3:site &lt;/site&gt; &lt;site-deploy&gt; org.apache.maven.plugins:maven-site-plugin:3.3:deploy &lt;/site-deploy&gt;&lt;/default-phases&gt; 看完clean以及site的生命周期阶段与插件目标的绑定关系后，我还想要看看default生命周期中的绑定关系是怎样的。我这里留到最后说default生命周期是因为它有一些特殊，如果你打开上文给的生命周期各阶段的链接后，你会发现官网告诉你说default生命周期没有关联到任何插件，然后又告诉你说绑定到这个生命周期中的插件是取决于packing的打包类型来单独定义的。 default lifecycle is defined without any associated plugin. Plugin bindings for this lifecycle are defined separately for every packaging 点开链接后我们就可以看到在default生命周期的处理上，针对不同的packing类型提供了不同的阶段到插件目标的绑定关系。一开始我没弄明白为什么要这么干，后来觉得应该是不同的打包类型取决于不同的应用场景，所以要根据需要使用不同的插件（个人理解）。例如packing类型为pom的通常不需要测试、编译这些处理。然后其他的打包类型，虽然大部分像资源处理、测试、编译都是需要的，但可以看到打包时所使用的插件还是不一样的。 例如packing类型为jar的和为war的package阶段绑定的插件就不一样。 123456789&lt;!-- packing为jar --&gt;&lt;package&gt; org.apache.maven.plugins:maven-jar-plugin:2.4:jar&lt;/package&gt; &lt;!-- packing为war --&gt;&lt;package&gt; org.apache.maven.plugins:maven-war-plugin:2.2:war&lt;/package&gt; 上面简单看了一下各个生命周期与插件目标的绑定关系，也对各个阶段的基本功能有了一些了解。但另一点我对Maven中default生命周期中大部分的阶段都没有绑定到实际的插件目标有些不太理解，在这里可以看到default生命周期中定义了一系列的阶段，但是将网页往下拉一点的Built-in_Lifecycle_Bindings中可以仔细看一下就可以发现default生命周期中并不是所有的阶段都绑定到了插件目标上。例如generate-test-sources、process-test-classes、integration-test等就没有具体的绑定关系，所以我猜想如果这些阶段得以执行的话，那么可能是Maven内部做了一些绑定处理，否则就是它们不会有实际的行为。，这点目前还需要进一步证实。 上面介绍完了maven中三大生命周期阶段到插件目标的绑定关系，对生命周期应该有一个初步的理解了。 在一开始对生命周期阶段的描述中提到了“阶段是有顺序的，而且后面的阶段会依赖前面的阶段。” 这里还以clean生命周期来举例说明： 当用户调用pre-clean的时候（在命令行输入mvn pre-clean的时候），只有pre-clean阶段得以执行；当用户调用clean的时候，pre-clean和clean阶段会按顺序执行；当用户调用post-clean的时候，pre-clean、clean和post-clean会按顺序执行。 并且上面说到生命周期是相互独立的，意思是说，我们可以调用某个生命周期中的某个具体的阶段，而命令执行时，不同的生命周期之间不会有影响。 用clean来举例只是帮助理解概念，事实上真正核心的生命周期是default，它里面定义了一系列的阶段。那么这时候我们就知道，我们执行default生命周期的install阶段时，在install阶段之前的所有阶段都会执行，从而可以帮我们完成validate、initialize、resources、compile、test等一系列的操作，从而来简化我们的工作。 这就是生命周期方便的地方以及它所完成的事情。 这里介绍一下在使用时如何执行生命周期的目标来完成相应的任务： 我们在命令行如果想要执行生命周期中的阶段时，可以不需要输入生命周期的名字，直接输入具体的阶段名称就可以。Maven会自己去找这个阶段是属于哪个生命周期，然后并执行他前面所有的阶段。例如想要执行default中的packge阶段完成打包操作，那么执行mvn packge就可以了。 此外，Maven也允许多个阶段一起执行（可以是不同生命周期中） 例如mvn clean deploy site-deploy执行了clean生命周期的clean阶段、default生命周期的deploy阶段，以及site生命周期的site-deploy阶段。实际执行的阶段为clean生命周期的pre-clean、clean阶段，default生命周期的所有阶段，以及site生命周期的所有阶段。 通常我们在使用时，会经常用到mvn clean package来在执行打包前清理上一次的构建。 插件和目标聚合和继承]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中finally和return的执行顺序]]></title>
    <url>%2F2018%2F06%2F27%2Fexecution-order-of-finally-and-return-in-java%2F</url>
    <content type="text"><![CDATA[try…catch…finally语句中return语句的执行测试. 有时候想起来finally和return语句的执行顺序上会有一些混乱, 这里写了几个测试例子来弄清楚它们的执行顺序, 虽然网上也有很多这样的文章, 但还是觉得自己实际写个例子体会一下会更加映像深刻些. 大致有2种形式, 分别是带有catch语句和不带catch语句: 不带有catch语句 try中有return语句, finally中没有return语句. try代码块和finally中都有return语句. 带有catch语句 try…catch…语句块中都有return语句, 但finally中没有return语句. try…catch…finally…语句块中都有return语句. 这里考虑catch语句的情况是因为, catch语句的加入会影响try语句的执行, 如果try和catch的语句块中都有return语句, 那么当try语句块中代码发生异常时, 那么就相当于if else的选择, 只能有一个return语句会被执行. 这个下文中会列举具体的情形代码. 我们先从简单的不带有catch代码块的情形开始出发来了解. 不带有catch语句的情形1. try中有return语句, finally中没有return语句.123456789101112131415161718192021222324public class ReturnAndFinalTest &#123; public static void main(String[] args) &#123; int i = new ReturnAndFinallyTest().test(); System.out.println("test方法返回值: " + i); &#125; public int test() &#123; int i = 100; try &#123; System.out.println("try代码块"); i += 10; return i; &#125; finally &#123; System.out.println("finally代码块, i = " + i); i += 20; &#125; &#125;&#125; 执行结果: try代码块finally代码块, i = 110test方法返回值: 110 通过这个测试结果可以看到以下现象: finally中的语句是在try中的return语句之后执行的. try中的return语句并没有真正的让方法返回. main方法中获取到值是110, 说明方法返回值不是finally中修改后的i变量值. 所以可以确定try中return语句的i变量值在执行finally语句之前就已经确定了. 结论: try中的return语句不会让方法真正返回, 但在return语句执行时就确定了方法最终的返回值, 真正的方法返回是在执行了finally语句块中的代码之后. 关于现象3, 我们会想到一个问题:在try中return语句返回的是一个基本类型int, 所以在finally中做赋值操作不会影响到返回的值, 但如果是一个引用类型, 我在finally中将引用的内容更改掉会不会影响try中return语句的返回的内容. 关于这点可以参考后文中的返回值为引用类型时是否会修改返回值 2. try代码块和finally中都有return语句.12345678910111213141516171819202122232425262728public class ReturnAndFinallyTest &#123; public static void main(String[] args) &#123; int i = new ReturnAndFinallyTest().test(); System.out.println("test方法返回值: " + i); &#125; public int test() &#123; int i = 100; try &#123; System.out.println("try代码块"); // 这里做一次赋值操作. return i += 10; &#125; finally &#123; System.out.println("finally代码块, i = " + i); i += 20; return i; &#125; &#125;&#125; 执行结果: try代码块finally代码块, i = 110test方法返回值: 130 通过这个测试结果可以看到以下现象: finally中获取到的i变量为110说明try中的return语句赋值操作生效了. 方法最终的返回为130说明try中return语句并没有真正的让方法返回. test方法返回值为130表示finally中的return语句生效了, 说明finally中的return让方法最终返回. 结论: try中的return语句虽然执行了但并没有引起方法的返回并且即使其中有return语句, 还是会执行finally中的代码, 当发现finally中也有return语句时, 就使用该return语句作为方法的最终返回值. 带有catch语句###1. try…catch…语句块中都有return语句, 但finally中没有return语句. 12345678910111213141516171819202122232425public class ReturnAndFinallyTest &#123; public static void main(String[] args) &#123; int i = new ReturnAndFinallyTest().test(); System.out.println("test方法返回值: " + i); &#125; public int test() &#123; int i = 100; try &#123; System.out.println("try代码块"); // 触发一个异常 int a = i / 0; return i += 10; &#125; catch (Exception e) &#123; System.out.println("catch代码块"); return i += 1; &#125; finally &#123; System.out.println("finally代码块, i = " + i); i += 20; &#125; &#125; &#125; 执行结果: try代码块catch代码块finally代码块, i = 101test方法返回值: 101 通过这个测试结果可以看到以下现象: try中的代码发生异常后, try代码块的return语句没有起作用. 方法返回值为101, 说明catch语句让方法返回了. 结论: 所以我们可以得出一个结论, try和catch其实从某个角度理解就像是if else, 如果try中有异常, 那就走catch流程, 如果没有那就走自己的流程. 所以具体执行try和catch中的哪个return语句是取决于try中是否有异常发生. 同时我们也可以看到在try和catch中都有return语句时, test方法就不需要在方法最末尾再去写return语句了, 因为try和catch中的return语句总有一个会执行. 2. try…catch…finally…语句块中都有return语句.12345678910111213141516171819202122232425public class ReturnAndFinallyTest &#123; public static void main(String[] args) &#123; int i = new ReturnAndFinallyTest().test(); System.out.println("test方法返回值: " + i); &#125; public int test() &#123; int i = 100; try &#123; System.out.println("try代码块"); int a = i / 0; return i += 10; &#125; catch (Exception e) &#123; System.out.println("catch代码块"); return i += 1; &#125; finally &#123; System.out.println("finally代码块, i = " + i); i += 20; return i; &#125; &#125;&#125; 执行结果: try代码块catch代码块finally代码块, i = 101test方法返回值: 121 通过这个测试结果可以看到以下现象: 方法返回值为121, 说明是catch中的return语句的赋值操作生效了, 但并没有让方法返回. 最后让方法返回是的finally中的return语句. 结论: 无论try和catch语句中是否有return, 都会执行finally中的代码并且如果finally中有return语句, 那么就以该return语句作为方法的返回. (这一点和之前的现象一样) 返回值为引用类型时是否会修改返回值1234567891011121314151617181920212223242526272829303132333435363738394041424344class User &#123; private String name; private int age; public User() &#123; &#125; public User(String name, int age) &#123; this.name = name; this.age = age; &#125; // getter and setter // toString&#125;public class ReturnAndFinallyTest &#123; public static void main(String[] args) &#123; User user = new ReturnAndFinallyTest().test(); System.out.println("test方法返回值: " + user); &#125; public User test() &#123; User user = null; User u1 = new User("用户1", 11); User u2 = new User("用户2", 12); try &#123; System.out.println("try代码块"); user = u1; return user; &#125; finally &#123; System.out.println("finally代码块"); user = u2; // user.setAge(13); &#125; &#125;&#125; 我们用到一个User类用来模拟一个对象, 然后再try代码块里面为User user引用, 赋值了u1这个对象, finally代码块里面为User user赋值为u2. 如果user = u2;语句影响到try代码块里的return user;的返回结果, 那么说明可以对引用的对象内容进行修改. 执行结果: 123try代码块finally代码块test方法返回值: User&#123;name=&apos;用户1&apos;, age=11&#125; 通过这个测试结果可以看到以下现象: main方法的输出结果说明, finally中对user的引用地址进行的修改是未生效的. 同样的和之前的基本数据类型int的测试结果一样, 在finally代码块的代码执行之前try中return user;的user引用就已经被确定下来, 无法将引用更改到其他的User对象上. 结论: 不管try中返回是基本类型还是引用类型, 在finally中是无法对try中return语句的返回值做修改的, 这里的返回值, 如果是基本类型, 那么传递的基本类型的变量值; 如果是引用类型, 那么传递的是引用类型的对象引用地址. 虽然在finally中更改try中return语句的引用地址, 但可以修改它引用的对象的内容, 例如上面注释的user.setAge(13);是可以操作成功的. 其实根本上就是java中的值传递问题, 基本类型传递的是值, 引用类型传递的是对象引用地址. 最后总结总结内容是从参考文章中的评论里拷贝过来的. (因为懒得自己写了…) finally块的语句在try或catch中的return语句执行之后返回之前执行且finally里的修改语句不能影响try或catch中 return已经确定的返回值，若finally里也有return语句则覆盖try或catch中的return语句直接返回。 执行时机问题。finally总会执行（除非是System.exit()），正常情况下在try后执行，抛异常时在catch后面执行，即使try和catch中存在return语句 finally中是否有return语句，决定了方法是否最终从finally中返回。 返回值问题。可以认为try（或者catch）中的return语句的返回值放入线程栈的顶部：如果返回值是基本类型则顶部存放的就是值，如果返回值是引用类型，则顶部存放的是引用。finally中的return语句可以修改引用所对应的对象，无法修改基本类型。但不管是基本类型还是引用类型，都可以被finally返回的“具体值”具体值覆盖 不建议在finally中使用return语句，如果有，eclipse会warning“finally block does not complete normally” 参考文章:Java finally语句到底是在return之前还是之后执行？]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一下 Invalid bound statement (not found) 的问题]]></title>
    <url>%2F2018%2F06%2F02%2FInvalid-bound-statement-not-found-in-mybatis%2F</url>
    <content type="text"><![CDATA[记一下在开发时出现的一个问题, 弄了很久才得到解决.网上查询到的回答大概都是如这篇文章回答的一样来解决 https://www.jianshu.com/p/800fe918cc7a但进行操作后依旧未能解决我的问题. 我的问题如下:我和同事共同负责系统模块的开发, 我的模块需要依赖他开发的模块. 我们的项目都是基于Spring Boot开发的项目, 我在Application的启动类中使用@MapperScan注解扫描我们两个人工程中的Mapper接口文件. 这里需要说明的是, 由于我们是开发两个模块, 所以在配置Mapper扫描包的路径需要是我们包路径的公共部分, 例如我的Mapper接口存放在了包com.xxx.system.user.mapper , 他的存放在com.xxx.system.blog.dao中. 所以这时候我配置的Mapper接口包扫描路径为@MapperScan(basePackages = {&quot;com.xxx.system&quot;}), 以便扫描到我们两个工程的Mapper接口包.但是这样设置后我遇到一个问题, 由于我们在开发中大多数也会在Service层提供一个抽象接口, 例如com.xxx.system.usser.service.IUserService, 然后还为该接口提供一个实现类UserServiceImpl. 这时候@MapperScan注解会发生一个错误, 会奇怪的将IUserService这个接口当做是Mybatis的Mapper接口, 然后还尝试拿去跟Mapper.xml中去做映射关联.这时候就会发生Invalid bound statement (not found)的问题. 解决方法是可以选择在@MapperScan注解中分两次配置两个工程的Mapper接口包路径, 或者将两个人的包命名为同一个路径下, 例如最后不要一个人是mapper中, 一个人是放在dao中, 统一一下, 这样就可以写成com.xxx.system.*.mapper用*通配符来代替中间的部分. 这里还说另一个问题, 是classpath*与classpath的问题. 由于是基于SpringBoot整合的Mybatis, 所以可以在application.properties用mybatis.mapper-locations来配置Mybatis的mapper.xml文件路径. 我在一开始配置的值是mybatis.mapper-locations=classpath:mapper/*Mapper.xml, 这个配置值存在的问题是, 如果在classpath的mapper文件夹中检查到了任意的Mapper.xml文件时, 都会返回结果停止往下继续匹配. 这里的问题是, 我依赖我同事的工程中, 也需要扫描classpath下他的Mapper.xml文件, 而此时无法找到他工程里的Maper.xml文件, 原因就是因为匹配到我工程里classpath中的Mapper.xml文件就停止了对他工程的匹配搜索. 解决的办法是将classpath:mapper/*Mapper.xml改为classpath*:mapper/*Mapper.xml. classpath*的作用是找到包括你依赖的jar文件在内的classpath中的资源文件. 本来想仔细探究一下这其中的究竟, 但因工作繁忙无暇深入去探索, 暂且记录一下留作以后参考.上网看了一下别人的博客, 介绍的classpath和classpath*的大概区别如下:https://blog.csdn.net/kkdelta/article/details/5507799http://kyfxbl.iteye.com/blog/1675362]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ps安装及破解过程]]></title>
    <url>%2F2018%2F05%2F21%2Fps-cs6-install-and-crack%2F</url>
    <content type="text"><![CDATA[经常有一些对PS感兴趣的朋友，问我PS怎么下载安装。因为PS是收费的，安装后还需要破解，步骤还是有些麻烦的，这里我写了个安装过程记录一下步骤，也给其它需要的朋友参考。 首先下载PS的安装包和破解文件, Adobe Photoshop CS6百度网盘下载地址: 链接: https://pan.baidu.com/s/1KCj9afywLdmL3J63r70QuQ 密码: nsgb 打开网盘链接后，把这两个文件下载下来。 提醒： 百度网盘下载有限速问题，会导致下载速度比较慢，可以看这里的方法进行解决：https://github.com/high-speed-downloader/high-speed-downloader 下载后，把压缩包都解压成文件夹。 左边的是破解程序的文件夹，右边是ps软件本身的安装文件夹。 下面是安装及破解步骤，先来安装PS软件本身。 找到ps软件的安装程序。依次打开找到Set-up.exe 打开后显示这样子，点击忽略就行了。 这时候选择试用 接下来点击接受，再点击登录后出来登录界面。输入账号密码，然后点击登录账号: keitpyocshe@hotmail.com密码:ITpegsItEimKee3点登录后可能有点慢，因为要去连接的国外的服务器验证账号密码的正确性。这里点击跳过 接下来选择安装位置进行安装就行了，安装位置建议选择安装到D盘。安装的地方要记住，后面还会用到的。 安装完成之后可以在桌面上找到ps的图标，如果桌面上没有，也可以在开始菜单中找到ps的图标随便选择一个打开，然后说是处于试用期。点击开始试用就可以了。 这样就完成安装了，下面开始破解，在开始破解之前记得关掉刚才打开的PS软件。 找到破解程序的文件夹，文件夹里的文件大概是这样子的。 左边的Crack.bat是屏蔽hosts文件地址用的(目的是为了屏蔽ps软件与服务器的通信阻止他验证软件的激活状态)。 右边的amtlib.dll是破解补丁文件。 先运行一下Crack.bat这个文件，运行的时候记得选择以管理员的身份运行(注意: 进行这个步骤时建议暂时退出杀毒软件。) 运行后弹出这个黑色窗口，提示按任意键继续后，随便按键盘上一个键关掉这个窗口就行。 现在打开ps软件的安装文件夹，比如我上面安装到了这个位置。 在安装目录下可以看到有5个文件夹，其中后面的2个文件夹带64 Bit的是64位的软件，不带的是32位。之前的破解补丁分别有32位和64位。 这时候，把它们里面的amtlib.dll文件分别复制到PS安装目录下对应的文件夹中替换掉原来的文件就行了。替换的时候记得选择第一个“复制和替换” 两个都替换掉之后，再次打开PS软件，这时候就看不到说试用了，这样就破解成功了。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>PS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018.05.17&18 EB拓展训练日志——感受与收获]]></title>
    <url>%2F2018%2F05%2F18%2FFeeling-and-growth-in-the-EB-Expand-training%2F</url>
    <content type="text"><![CDATA[前两天（18.05.17&amp;18）参加了公司安排的拓展式学习，参加了4个主项目，还有1个17日晚饭后的游戏节目。目的是增强自我认知，了解自己在团队中的角色地位，培养团队合作意识等。总得来说，在这2天的收获还是有一些的。 回想这两天的经历，更多让我感受到的是这两天的意义是在于让我们更好的去认知自己，通过真实的切身体验去学习、去锻炼、去提升。在这次体验中观察到也学习到很多团队中真正欠缺的与应该所具备的。团队需要一个合格的领导者，团队中有各色的人，人与人之间存在差异与个性，这就会产生包括但不限存在于沟通、理解、执行、配合以及因情绪上等问题。我想最一开始，因为陌生因为不了解，我们没有选择愿意去服从谁、相信谁、放心谁。我认为团队真正需要的是一名有能力、具备让大家信服的能力并能够担当的人去进行领导，懂得去管理组织团队，协调团队里每个人员的的相互配合。在此基础上同样重要的一点是团队里的每个人也要具备相互信任及合作的意识。做到抛开个人情感、性格因素等个性化差异真正的进入角色融入到团队中。这正是在职场或者与其他团队活动时所需要达到的，如果我们可以更好的管理个人情绪、情感去面对身边的人一起去做一些事，也许我们就会变得优秀许多。 17号白天下午我们进行了一个项目，一共分为6个小组分别参与项目比赛，根据地图以及指北针进行定向越野，从地图上的起始点进行到终点，在地图上一共有8个点需要进行签到，我们要做到在每一次签到后都需要确认到达下一个签到点的方向。项目中只提供了两个工具——指北针和地图。我们需要借这两样工具来完成项目进行越野。其实说句实话，完成项目不是很难，从起点到达终点也不是重要的地方。 我想说的是，重在过程，回想我们在完成每一个签到点即将进行下一次跋涉时，我们会存在迷茫、争议、怀疑、犹豫等等各种复杂的情绪及体验。当我们到达地图上的某个十字路口，摆在我们的面前有很多条道路，这时候我们会有不同的选择，但与此同时，随之而来伴随我们的是迷茫与不未知。而此时，我们是一个有着五六个人的小组，也许领队的伙伴会带领你选择某条道路，帮你确定答案解决你的疑惑，但也会因不同的人有不同的意见充满着争议。其实通过这个项目，令我感受最深也让我想到最多的是关于我们人生道路的问题。我们从起点经过一系列的艰辛到达我们最终的终点，其实这更对称了一句有始有终的话。我们知道从何开始，也知道要去往何处，但重在过程。在过程中，我们每一次面对路口又或是我们完成了一次打卡要开始下一段路程时，就像是我们人生中要面临选择的时候，我充满着迷茫、为知以及因为未知而感受到的一丝恐惧，在我们的人生中，如果我们没有指北针，没有地图，也没有身边的伙伴的情况下，我们是否能够做出正确的判断去选择我们的人生道路，我们又是否有勇气去迈出我们的步伐。同样地，无论我们路过了哪些风景美丽的地方又或是因身体疲惫我们想要放弃前行，我们都依然只能选择继续前行；无论我们脚底下是平坦还是坎坷，我们都要脚踏实地走好每一步，直至我们到达终点。 越野项目结束后，我记得赵老师给我们讲话时，用“谈恋爱的道理”来给我们讲职场中的规则，我很认同这一点的适用性。在工作中，你想要在同事、领导面前被认同，你就要将自己的优势，自己好的一面展现给别人，换句话说你要让对方明白你的价值所在。其实，不光是工作，在人际交往中也同样如此。总听人说友情是建立在利益至上，虽不绝对如此，但就观点来说，如果你能够主动帮助别人让别人感受到你的价值所在，那才会是别人愿意同你交往、愿意需要你的理由。 赵老师期间还提到一句话——那些在你人生中的挫折、困难、坎坷以及糟糕的事，才是让你铭记于心难以忘记的真正对你有用的。回想起这句话，我想到是在我们人生不难免会遇到各种各样的困难、挑战、挫折等，但如果我们不是去逃避而是报以坦然以及自律的心态去面对它们去解决它们时，我们会收获更多的成长与快乐幸福。 17号晚饭后做了一个游戏，事后也令我有一些感触，尤其过程中一个同事的行为以及后来赵老师的一番话。游戏是将参与者分成两队，每队的人分成一列前后对齐站整齐，要求从最后的人将所接收到的数字告知队伍最前面的人。针对游戏设定了一系列的规则，来增加游戏难度，比如不能说话，不能移动位置等一些限制性的规则。说实话，在游戏的时候我是没有想要去挑战规则或者说根本没去想做一些规则以外的事情。直至游戏最终结束，其实带给我们的是，我们总是被规则限制，而固化了思维，没有想去改变什么的，我们墨守成规，却忽略了在条件允许的情况下达到结果达到目的最直接最简单的方法。我想这是值得我所反思的。借着聊天，赵老师还讲到了一个人际交往中的“白金法则”，强调的是在人际交往中，我们要真诚去对待对方，这样才能被对方肯定，对方自然也会这样回应你。这令我想到，很多事都可以从相对的角度作为出发点去考虑，你想要变得幸福，你就要做让自己觉得幸福的事；你想要拥有优秀美好的东西，你就要把自己变得优秀卓越；你想要别人爱你，真诚地对待你，你就要真诚的去对待去爱对方。 回想这两天还想说一件让我很开心的事，那就是我的一位同事兼我的好友。我在他身上算是学到不少东西或者说他带给我的。用我之前的一句话说社会是一个大学堂，每个人都能教会你一些东西，那么我想说他就算一位。也不知道是在听了赵老师给我们讲话时提到的我们应该多开放一些自己的内心还是因白天的体验是我之前从未经历过让我很愉悦的原因，当晚我跟他聊了很多，有关于人生想法的、关于做人、关于以前生活的等诸多方面，只记得聊得很晚，我们也彼此分享很多过去的经历、心事，并去理解对方，针对问题给对方解决的建议、指点等等。这是至今以来从未拥有的畅快感，是那种找到知心好友，是那种堵在你内心不知道该找谁诉说又担心说出口会无人理解的事情得以说出口被理解的感觉。我以前是那种挺宅的人，平时很喜欢一个人把事情放在心里想，也从未找到一个合适的朋友与时机去与人诉说。这次的聊天是令我很开心也令我多少有一些收获。我是那种平时会反思自己以及生活的人，我想要过平凡的生活却不想活得平淡，即使现在的我很普通也不足够优秀，但我一直都未曾想要停止变得优秀的脚步。值得开心的是，我在这位好友的身上也发现了这一点，这是令我很欣赏的地方。 在这次的体验式学习中，让我认识到自己很多问题，比如最基本的团队合作能力，无法做到把自己真正融入到团队中的，放不开以及由于陌生带来的隔阂感，不自信以及与人沟通交往能力，没有那种很自然的与人沟通，没有去开口主动了解别人，借赵老师的话来说甚至连基本的组员的姓名都不曾去问过。这些都是在今后需要努力去改变去解决的问题。我想我可能需要更多的此类活动来对自己有更好地认知，使自己得到提升锻炼以及慢慢将自己放开融入集体的团队活动中。 最后，这两天，其实真的比较开心，身心上很愉悦。在这里感谢这两天活动中所有的领导、老师以及相关事物的负责人员。感谢您们提供可口美味的饭菜、选择风景的美好的地方进行培训以及安排了舒适的住宿条件。也感谢在一起合作的一群人，很开心能够与你们一同参与活动，让我能够得以学习并拥有以前从未有过的体验以及新鲜感。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>拓展训练</tag>
        <tag>体验式学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A标签onclick事件取消默认行为]]></title>
    <url>%2F2017%2F11%2F24%2Fonclick-event-on-an-a-element%2F</url>
    <content type="text"><![CDATA[在开发中，经常会碰到为a标签绑定单击事件，由于a标签默认有跳转的行为，所以会影响到我们的onclick事件的处理代码。 我们需要屏蔽掉他的默认行为，下面是一些常用的方式。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;方式1: href="javascript:void(0)"&lt;/h1&gt;&lt;a href="javascript:void(0)" onclick="alert('方式1, 执行一段代码.')"&gt;情形1: 执行一段代码.&lt;/a&gt; &lt;br/&gt;&lt;a href="javascript:void(0)" onclick="popup()"&gt;情形2: 调用一个已声明的js函数.&lt;/a&gt; &lt;br/&gt;&lt;a href="javascript:void(0)" id="manual_bind_click_way1"&gt;情形3: 手动绑定click事件&lt;/a&gt; &lt;br/&gt;&lt;h1&gt;方式2: onclick="return false;"&lt;/h1&gt;&lt;a href="http://www.google.com" onclick="alert('方式2, 执行一段代码.'); return false;"&gt;情形1: 执行一段代码.&lt;/a&gt; &lt;br/&gt;&lt;a href="http://www.google.com" onclick="popup(); return false;"&gt;情形2: 调用一个已声明的js函数.&lt;/a&gt; &lt;br/&gt;&lt;a href="http://www.google.com" id="manual_bind_click_way2"&gt;情形3: 手动绑定click事件&lt;/a&gt;&lt;script&gt; // 已声明函数popup function popup() &#123; alert("弹窗测试."); &#125; // 手动绑定click window.onload = function () &#123; var aEle_way1 = document.getElementById("manual_bind_click_way1"); // 方式1 a标签. aEle_way1.onclick = function () &#123; alert("手动绑定click事件."); &#125; var aEle_way2 = document.getElementById("manual_bind_click_way2"); // 方式2 a标签. aEle_way2.onclick = function () &#123; alert("手动绑定click事件."); return false; &#125; &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在实现上大概有两种方式： 方式1: 为href属性添加javascript:void(0)来构造伪链接, 即为：href=&quot;javascript:void(0)&quot; 方式2: 添加onclick属性并在事件处理代码中通过return false;来屏蔽默认行为, 即为：onclick=&quot;return false;&quot;(这种方式表示希望保留href属性的内容.) 这两种方式都会直接的屏蔽跳转行为. 我们在开发中可能会遇到如下3种情况, 比如说 单击a标签后, 执行一段js代码. (如情形1) 单击a标签后, 调用js中已经声明的函数. (如情形2, 这种情况大家一般传递this对象, 即: onclick=&quot;popup(this)&quot;) 我们想要手动为a标签绑定单击事件, 但是在事件执行后依然不希望a标签跳转. (如情形3) 需要说明的是如果以方式2的来实现情形3, 那么需要onclick事件处理最后返回false, 即return false, 否则执行完click事件后依然会跳转.]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud Netflix多语言/非java语言支持Sidecar]]></title>
    <url>%2F2017%2F09%2F12%2Fpolyglot-support-with-sidecar%2F</url>
    <content type="text"><![CDATA[前言公司有一个调研要做，调研如何将Python语言提供的服务纳入到Spring Cloud管理中来，找到了这个Sidecar组件，发现官方提供一篇文档如下，对其进行相关翻译。 Sidecar简介根据我的理解，Sidecar是作为一个代理的服务来间接性的让其他语言可以使用Eureka等相关组件。通过与Zuul的来进行路由的映射，从而可以做到服务的获取，然后可以使用Ribbon，Feign对服务进行消费，以及对Config Server的间接性调用。(此段内容仅个人理解，只作为参考，欢迎讨论，同时有误请及时指正。) 正文翻译以下是原文翻译，原文地址：https://cloud.spring.io/spring-cloud-netflix/multi/multi__polyglot_support_with_sidecar.html 你是否想要在非jvm的语言中利用（间接性使用）Eureka，Ribbon以及Config Server？Spring Cloud Netflix Sidecar的设计灵感来自Netflix Prana。它包含一个简单的http api去获取一个已知服务的所有实例(例如主机和端口)。你也可以通过嵌入的Zuul代理(Zuul中有一个代理功能)对代理的服务进行调用，Zuul从Eureka服务注册中心获取所有的路由记录(route entries)。通过host发现(host lookup)或者Zuul代理可以直接访问Spring Cloud Config。非jvm应用应该实现一个健康检查，Sidecar能够以此来报告给Eureka注册中心该应用是up还是down状态。 在你的项目中使用Sidecar，需要添加依赖，其group为org.springframework.cloud，artifact id为spring-cloud-netflix-sidecar。(这是以maven依赖的方式) 启用Sidecar，创建一个Spring Boot应用程序，并在在应用主类上加上@EnableSidecar注解。该注解包含@EnableCircuitBreaker, @EnableDiscoveryClient以及@EnableZuulProxy。Run the resulting application on the same host as the non-jvm application. (这句不太会翻译，我的理解为：在与非jvm应用程序相同的主机上运行生成的应用程序)注：这里的生成应该是通过代理产生的服务。 配置Sidecar，在application.yml中添加sidecar.port和sidecar.health-uri。sidecar.port属性是非jre程序监听的端口号，这就是Sidecar可以正确注册应用到Eureka的原因。sidecar.health-uri是非jre应用提供的一个对外暴露的可访问uri地址，在该地址对应的接口中需要实现一个模仿Spring Boot健康检查指示器的功能。它需要返回如下的json文档。(注：通过返回一个json，其用status字段来标识你的应用的服务状态，是up还是down，sidecar会将该状态报告给eureka注册中心从而实现你的服务的状态可用情况。简单的说就是用来控制sidecar代理服务的状态！)health-uri-document. health-uri-document.(heal-uri指向的接口地址需要返回的json文档)123&#123; "status":"UP"&#125; 这里是一个Sidecar应用程序的application.yml配置示例： application.yml123456789server: port: 5678spring: application: name: sidecarsidecar: port: 8000 health-uri: http://localhost:8000/health.json API DiscoveryClient.getInstances()所对应的访问方式是/hosts/{serviceId}，这是访问/hosts/customers后的响应示例，它返回了两个不同主机上的实例(可以看到主机地址不一样)。非jre程序可以访问这个api，如果sidecar的端口号为5678，那么完整url则为：http://localhost:5678/hosts/{serviceId}. /hosts/customers.12345678910111213141516[ &#123; "host": "myhost", "port": 9000, "uri": "http://myhost:9000", "serviceId": "CUSTOMERS", "secure": false &#125;, &#123; "host": "myhost2", "port": 9000, "uri": "http://myhost2:9000", "serviceId": "CUSTOMERS", "secure": false &#125;] Zuul代理会自动为每个在Eureka注册中心上的服务添加路由到/serviceId上，所以上面那个customers的服务可以通过/customers访问。非Jre应用可以通过http://localhost:5678/customers来访问Customer Service(假设Sidecar的监听端口为5678) 如果Config Server注册到了Eureka，非jre应用就可以通过Zuul代理访问它。如果ConfigServer的serviceId为configserver并且Sidecar的端口为5678，那么可以通过http://localhost:5678/configserver 的方式来访问Config Server。 非Jvm应用可以利用Config Server的能力来获取Config Server返回的YAML文档，通过访问 http://sidecar.local.spring.io:5678/configserver/default-master.yml 就可以获取到类似下面的YAML文档结果12345678eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ password: passwordinfo: description: Spring Cloud Samples url: https://github.com/spring-cloud-samples]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Spring Cloud</tag>
        <tag>Sidecar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Sidecar将Node.js引入Spring Cloud]]></title>
    <url>%2F2017%2F09%2F11%2Fusing-sidecar-to-integration-with-nodejs-in-springcloud%2F</url>
    <content type="text"><![CDATA[网上看到的一篇文章，觉得写得挺好，现转载于此，以方便需要的网友查阅。该文章介绍了非JAVA语言提供的应用集成到Spring Cloud的这样一个实现，以便我们使用其他语言作为参考。感谢原作者分享，原文链接： https://github.com/marshalYuan/spring-cloud-example/blob/master/docs/sidecar.md 注：其中图片如果看不清，可以右键新窗口打开查看大图。 使用Sidecar将Node.js引入Spring Cloud理论简介Spring Cloud是目前非常流行的微服务化解决方案，它将Spring Boot的便捷开发和Netflix OSS的丰富解决方案结合起来。如我们所知，Spring Cloud不同于Dubbo，使用的是基于HTTP(s)的Rest服务来构建整个服务体系。 那么有没有可能使用一些非JVM语言，例如我们所熟悉的Node.js来开发一些Rest服务呢？当然是可以的。但是如果只有Rest服务，还不能接入Spring Cloud系统。我们还想使用起Spring Cloud提供的Eureka进行服务发现，使用Config Server做配置管理，使用Ribbon做客户端负载均衡。这个时候Spring sidecar就可以大显身手了。 Sidecar起源于Netflix Prana。他提供一个可以获取既定服务所有实例的信息(例如host，端口等)的http api。你也可以通过一个嵌入的Zuul，代理服务到从Eureka获取的相关路由节点。Spring Cloud Config Server可以直接通过主机查找或通过代理Zuul进行访问。 需要注意的是你所开发的Node.js应用，必须去实现一个健康检查接口，来让Sidecar可以把这个服务实例的健康状况报告给Eureka。 为了使用Sidecar，你可以创建一个带有@EnableSidecar注解的Spring Boot程序。我们来看下这个注解都干了什么： 12345678910@Enable@EnableDiscoveryClient@EnableZuulProxy@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(SidecarConfiguration.class)public @interface EnableSidecar &#123;&#125; 看，hystrix的熔断器、Eureka的服务发现、zuul代理，这些该有的部件，都已经开启。 健康检查接下来需要在application.yml里加入sidecar.port和sidecar.health-uri的配置。其中sidecar.port属性代表这个Node.js应用监听的端口。这是为了让sidecar可以正常的注册到Eureka服务中。sidecar.health-uri是一个用来模拟Spring Boot应用健康指标的接口的uri。它必须返回如下形式的json文档：health-uri-document 123&#123; "status":"UP"&#125; 整个Sidecar应用的application.yml如下：application.yml 123456789server: port: 5678spring: application: name: sidecarsidecar: port: 8000 health-uri: http://localhost:8000/health.json 服务访问构建完这个应用，你就可以使用/hosts/{serviceId}这个API来获取DiscoveryClient.getInstances()的结果。这里有一个从/hosts/customers返回两个来自不同host的实例信息的例子。如果sidebar运行在5678端口， 那么Node.js应用是可以通过http://localhost:5678/hosts/{serviceId}访问这个api的。 /hosts/customers 12345678910111213141516[ &#123; "host": "myhost", "port": 9000, "uri": "http://myhost:9000", "serviceId": "CUSTOMERS", "secure": false &#125;, &#123; "host": "myhost2", "port": 9000, "uri": "http://myhost2:9000", "serviceId": "CUSTOMERS", "secure": false &#125;] Zuul proxy可以自动每一个注册到Eureka的关联到/&lt;serviceId&gt;的服务添加路由，因此customer服务是可以通过/customers这个URI访问的。同样假定sidecar监听在5678端口，这样我们的Node.js应用就可以通过http://localhost:5678/customers访问这个customer服务。 Config Server如果我们使用了Config Server服务，并且把它注册到Eureka，Node.js应用就可以通过Zull Proxy来访问它。如果ConfigServer的serviceId是configserver并且Sidecar监听在5678端口，然后就可以通过http://localhost:5678/configserver来访问Config Server。当然这也得益于Eureka，Config Server都提供了基于HTTP协议的Rest接口。 Node.js应用也可以利用Config Server的能力获取一些如YAML格式的配置文档。例如，一个对http://sidecar.local.spring.io:5678/configserver/default-master.yml的访问，可能获得如下的YAML文档的返回： 12345678eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ password: passwordinfo: description: Spring Cloud Samples url: https://github.com/spring-cloud-samples 所以将Node.js应用通过Sidecar接入Spring Cloud微服务集群的整体架构，大致就如下图: demo实践我们假设下有这样一个非常简单的数据，它叫User： 12345class User &#123; private Long id; private String username; private Integer age;&#125; 看起来非常经典哈！ 还有一个数据结构是用来表示书的，Book： 12345678class Book &#123; private Long id; private Long authorId; private String name; private String publishDate; private String des; private String ISBN;&#125; Book中的authorId对应User的id，现在我们要为这两种数据开发Rest服务了。 首先是User，我们使用spring来开发，先在controller的构造方法里，mock一些假数据users，然后非常简单的一个根据id查用户的Get接口： 12@GetMapping("/&#123;id&#125;")public User findById(@PathVariable Long id) &#123;&#125; 启动后，我们curl访问下： curl localhost:8720/12 {&quot;id&quot;:12,&quot;username&quot;:&quot;user12&quot;,&quot;age&quot;:16} 接下来，我们使用Node.js开发Book相关的接口。 由于Node.js社区十分活跃，可选的Rest服务框架非常多。比较主流的有express，koa, hapi等，非常轻量易扩展的也有像connect这样的，这里笔者考虑到群众基础和文档丰富度，选择使用express来开发这样一个可以接入Spring Cloud的Rest服务。 123456789101112131415161718192021222324252627282930313233343536373839const express = require('express')const faker = require('faker/locale/zh_CN')const logger = require('morgan')const services = require('./service')const app = express()let count = 100const books = new Array(count)while (count &gt; 0) &#123; books[count] = &#123; id: count, name: faker.name.title(), authorId: parseInt(Math.random() * 100) + 1, publishDate: faker.date.past().toLocaleString(), des: faker.lorem.paragraph(), ISBN: `ISBN 000-0000-00-0` &#125; count --&#125;app.use(logger('combined'))//服务健康指标接口app.get('/health', (req, res) =&gt; &#123; res.json(&#123; status: 'UP' &#125;)&#125;)app.get('/book/:id', (req, res, next) =&gt; &#123; const id = parseInt(req.params.id) if(isNaN(id))&#123; next() &#125; res.json(books[id])&#125;)//.... 也是先用faker来mock100条数据,然后写一条简单的get路由。 启动后，我们用浏览器访问下http://localhost:3000/book/1 现在我们已经有了两个微服务，接下来我们启动一个Sidecar实例，用于将Node.js接入Spring Cloud。 1234567@SpringBootApplication@EnableSidecarpublic class SidecarApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SidecarApplication.class, args); &#125;&#125; 非常简单，需要注意的是，在这之前，你需要一个eureka-server，为了测试sidecar代理访问Spring Config的能力，我还使用了config-server，相信熟悉spring cloud的同学应该都知道吧。 在sidecar的配置中，bootstrap.yaml中就是简单指定下服务端口跟config-server的地址,而node-sidecar.yaml配置如下： 123456789101112131415eureka: client: serviceUrl: defaultZone: $&#123;EUREKA_SERVICE_URL:http://localhost:8700/eureka/&#125;sidecar: port: 3000 home-page-uri: http://localhost:$&#123;sidecar.port&#125;/ health-uri: http://localhost:$&#123;sidecar.port&#125;/healthhystrix: command: default: execution: timeout: enabled: false 这里指定了sidecar所指向的node.js服务的地址,hystrix.command.default.execution.timeout.enabled: false主要是因为sidecar使用了hystrix的默认为一秒的超时熔断器，国内访问github的速度你懂的，我在测试时访问config-server经常超时，所以我就把它跟disable掉了，你也可以选择把超时时间配长一点。 将eureka-server，config-server，user-service，node-sidecar, node-book-service都启动后，我们打开eureka的主页面http://localhost:8700/： 看到我们的服务都处于UP状态，说明一切正常。接下来在看看Node.js应用的控制台： 发现已经有流量打进来了，访问的接口是/health，很明显这就是node-sidecar对我们的node应用进行健康检查的调用。 接下来就是见证奇迹的时刻了，我们curl访问sidecar的8741端口: curl localhost:8741/user-service/12 {&quot;id&quot;:12,&quot;username&quot;:&quot;user12&quot;,&quot;age&quot;:16} 跟直接访问user-service结果一致，说明sidecar的Zuul Proxy可以将我们的请求代理到user-service服务。 好了，借助这个代理，我们希望book服务能够提供作者信息的接口： 1234567891011121314151617181920212223242526272829const SIDECAR = &#123; uri: 'http://localhost:8741'&#125;const USER_SERVICE = 'user-service'const getUserById = (id) =&gt; fetch(`$&#123;SIDECAR.uri&#125;/$&#123;USER_SERVICE&#125;/$&#123;id&#125;`).then((resp)=&gt;resp.json())app.get('/book/:bookId/author', (req, res, next) =&gt; &#123; const bookId = parseInt(req.params.bookId) if(isNaN(bookId))&#123; next() &#125; const book = books[bookId] if(book) &#123; let uid = book.authorId services.getUserById(uid).then((user) =&gt; &#123; if(user.id) &#123; res.json(user) &#125;else&#123; throw new Error("user not found") &#125; &#125;).catch((error)=&gt; next(error)) &#125;&#125;)//根据uid，filter出authorId为uid的所有书app.get('/books', (req, res, next) =&gt; &#123; const uid = req.query.uid res.json(books.filter((book)=&gt;book.authorId == uid))&#125;) 我们访问下http://localhost:3000/book/2/author,可以看到返回了bookId为2的作者信息。但是这里有一个问题，我们并不能像代理到user-service那样通过访问http://localhost:8741/node-sidecar/book/1来访问Node.js的接口，那么怎么让user-service拿到book-service的数据呢？看下最开始的理论知识部分，我们可以通过访问/hosts/&lt;serviceId&gt;获取到各个服务的相关信息，我们来试下访问http://localhost:8741/hosts/node-sidecar得到如下结果： 可以看到返回信息里有Node.js应用的uri等信息，那么是不是我们可以先访问下sidecar的这个接口，拿到真实的uri之后，再来调用book-service的/books?uid=&lt;uid&gt;接口呢？当然可以，事实上spring cloud中已经有工具帮我们做这个事情，就是Feign，新建BookFeighClient.java： 12345@FeignClient(name = "node-sidecar")public interface BookFeignClient &#123; @RequestMapping("/books") public List&lt;Book&gt; findByUid(@RequestParam("uid") Long id);&#125; FeignClient可以自动根据serviceId去Eureka上找到对应的服务地址，如果该服务的实例不止一个，就会使用Ribbon进行客户端负载均衡，再加上一些像RequestMapping的注解，可以让客户端跟服务端controller保持一致。通过定义的这个findByUid方法，我们就可以轻松调用上面Node.js中定义的/books?uid=&lt;uid&gt;的接口了。这一点儿，也和我们上面画的sidecar架构图一致。 有了，我们再在user-service中定义这样一个新类型Author，它继承自User，加了一个books字段: 123class Author extends User &#123; private List&lt;Book&gt; books;&#125; 再加入一个获取author的接口： 1234567891011@GetMapping("/author/&#123;id&#125;")public Author getAuthor(@PathVariable Long id) &#123; List&lt;Book&gt; books = bookFeignClient.findByUid(id); User user = findById(id); Author author = new Author(); author.setId(user.getId()); author.setUsername(user.getUsername()); author.setAge(user.getAge()); author.setBooks(books); return author;&#125; 逻辑也很简单，获取对应user，根据uid从bookFeignClient获取books，然后构建author返回。 我们访问下http://localhost:8720/author/11看下返回结果： 需要注意由于是随机数据，可能需要换几个authorId才能看到这样的结果。 好了，到现在为止，我们已经完成了JAVA和Node.js两种语言借助sidecar和通用的http协议完成互相调用的全过程。关于更多的类似从config-server获取配置信息，从Eureka获取应用信息等操作，可以去下载我实验用的源码来了解。 我把整个DEMO放在了我的github中了，大家可以直接clone下来 git clone https://github.com/marshalYuan/spring-cloud-example.git 整个工程大致是这样的： eureka-server //对应上图的Eureka Server config-server //对应上图的Config Server config-repo //config-server仓库地址的searchPath user-service //java开发的服务，既是服务提供者(Provider)也是消费者(Coustomer) node-sidecar //一个sidecar实例，负责连接node和spring-cloud book-service-by-node //express.js开发的Rest服务 大家可以按照： eureka-server -&gt; config-server -&gt; user-service -&gt; book-service-by-node -&gt; node-sidecar 这样的顺序启动这五个应用，由于是测试用demo，所以有bug我也不管哈。 写在结尾正如开篇所说，得益于通用的Http协议和Netflix丰富的套件，我们可以将很多像Node.js，PHP，Python这样的非JVM语言接入Spring Cloud这个非常成熟的微服务框架，来迅速构建我们的微服务业务系统。你可能会说为什么不都用java呢？确实，一个系统单一语言开发维护成本确实会低很多，但还有一些其他情况值得我们去选择sidecar方案。 比如，历史包袱太重，想切到java平台，但是又不想完全重写过去的服务，这样就可以以统一协议为代价来进行整合，从java切到其他平台亦是如此。 还有一个说法叫”拥抱语言红利”，选择一种开发语言就代表选择一种编程思想已经这门开发语言对应的工具和库。比如现在很流行用Python做数据分析，那么微服务系统中这一部分的业务是不是可以用Python开发啊；Node.js的异步事件事件驱动机制很优秀，能不能用它来开发一些需要处理大量异步请求的服务啊；诸如此类。这里确实不是在引发”最优语言圣战”哈，私以为脱离了使用场景和生态来进行语言优劣的比较就是耍流氓。就拿计算100以内的所有勾股数为例，我不觉得有什么语言能像Haskell的代码这样简洁易懂： 1[ (x,y,z) | x &lt;- [1..100], y &lt;- [x..100], z &lt;- [x..100], x*x + y*y == z*z ] 再说了，我们标题中选的是Node.js，最好的语言明明是PHP啊！逃~~~]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>Spring Cloud</tag>
        <tag>Sidecar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用其他(非java)语言开发Eureka客户端]]></title>
    <url>%2F2017%2F09%2F06%2Feureka-rest-operations%2F</url>
    <content type="text"><![CDATA[前言公司需要调研Eureka在非JAVA语言中的使用，我在Eureka的官方github上找到了一份wiki，是官方提供的Eureka一些REST操作API，其他语言可以使用这些API来实现对Eureka Server的操作从而实现一个非jvm语言的Eureka Client。 这篇博文主要是对Eureka官方的提供的REST操作的WIKI做了翻译，并没有提供具体的实际案例代码。不过今天（2017-9-20）我在阅读《Spring Cloud与Docker微服务架构实战》书中看到了有这部分的使用说明，其中4.9节介绍了详细使用过程。如果有需要的话可以参考一下。另外如果感兴趣可以看看书中8.11节“使用Sidecar整合非JVM微服务”这部分，关于这部分的内容本人博客也有两篇相关博文：Spring Cloud Netflix多语言/非java语言支持之Sidecar使用Sidecar将Node.js引入Spring Cloud 版本说明Eureka REST operations翻译的版本为David Liu 在2016年2月26编辑的版本。英文原文地址：https://github.com/Netflix/eureka/wiki/Eureka-REST-operations 正文翻译下面是可用于非JAVA应用的Eureka REST操作。 appID是应用程序的名称，instanceID是与服务实例相关联的唯一id。在AWS云中，instanceID是服务实例的实例id，在其他数据中心(非AWS环境)，它是服务实例的主机名。 对下面的JSON/XML格式而言，内容的类型必须是application/xml 或 application/json。 操作 HTTP action 描述 注册新的应用实例 POST /eureka/v2/apps/appID 接受JSON/XML格式请求，返回204响应码表示成功 取消注册(de-register)应用实例 DELETE /eureka/v2/apps/appID/instanceID 返回响应码200表示成功 发送应用实例心跳 PUT /eureka/v2/apps/appID/instanceID 返回响应码200表示成功，404表示instanceID不存在 查询所有实例 GET /eureka/v2/apps 返回响应码200表示成功，响应内容格式JSON/XML 为所有appID实例做查询(Query for all appID instances) GET /eureka/v2/apps/appID 返回响应码200表示成功，响应内容格式JSON/XML 为特定的appID/instanceID做查询 GET /eureka/v2/apps/appID/instanceID 返回响应码200表示成功，响应内容格式JSON/XML 为特定的instanceID做查询 GET /eureka/v2/instances/instanceID 返回响应码200表示成功，响应内容格式JSON/XML 停止服务实例(Take instance out of service) PUT /eureka/v2/apps/appID/instanceID/status?value=OUT_OF_SERVICE 返回响应码200表示成功，500失败。 将实例恢复到服务(移除覆盖) DELETE /eureka/v2/apps/appID/instanceID/status?value=UP (value=UP是可选的，它被建议用于fallback状态，由于取消了覆盖) 返回响应码200表示成功，500失败。 更新元数据 PUT /eureka/v2/apps/appID/instanceID/metadata?key=value 返回响应码200表示成功，500失败。 查询特定vip address 下的所有实例 GET /eureka/v2/vips/vipAddress 返回响应码200表示成功，响应内容格式：JSON/XML，返回404表示vipAddress不存在 查询特定secure vip address下所有实例 GET /eureka/v2/svips/svipAddress 返回响应码200表示成功，响应内容格式：JSON/XML，返回404表示svipAddress不存在 服务注册 在进行注册时，你需要提交符合该XSD的XML(或JSON): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" attributeFormDefault="unqualified"&gt; &lt;xsd:element name="instance"&gt; &lt;xsd:complexType&gt; &lt;xsd:all&gt; &lt;!-- hostName in ec2 should be the public dns name, within ec2 public dns name will always resolve to its private IP --&gt; &lt;!-- ec2中的主机名应该是公告的dns名称，在ec2内，公共dns名称将始终对其私有IP进行解析 --&gt; &lt;xsd:element name="hostName" type="xsd:string" /&gt; &lt;xsd:element name="app" type="xsd:string" /&gt; &lt;xsd:element name="ipAddr" type="xsd:string" /&gt; &lt;xsd:element name="vipAddress" type="xsd:string" /&gt; &lt;xsd:element name="secureVipAddress" type="xsd:string" /&gt; &lt;xsd:element name="status" type="statusType" /&gt; &lt;xsd:element name="port" type="xsd:positiveInteger" minOccurs="0" /&gt; &lt;xsd:element name="securePort" type="xsd:positiveInteger" /&gt; &lt;xsd:element name="homePageUrl" type="xsd:string" /&gt; &lt;xsd:element name="statusPageUrl" type="xsd:string" /&gt; &lt;xsd:element name="healthCheckUrl" type="xsd:string" /&gt; &lt;xsd:element ref="dataCenterInfo" minOccurs="1" maxOccurs="1" /&gt; &lt;!-- optional 可选 --&gt; &lt;xsd:element ref="leaseInfo" minOccurs="0"/&gt; &lt;!-- optional app specific metadata --&gt; &lt;xsd:element name="metadata" type="appMetadataType" minOccurs="0" /&gt; &lt;/xsd:all&gt; &lt;/xsd:complexType&gt; &lt;/xsd:element&gt; &lt;xsd:element name="dataCenterInfo"&gt; &lt;xsd:complexType&gt; &lt;xsd:all&gt; &lt;xsd:element name="name" type="dcNameType" /&gt; &lt;!-- metadata is only required if name is Amazon --&gt; &lt;xsd:element name="metadata" type="amazonMetdataType" minOccurs="0"/&gt; &lt;/xsd:all&gt; &lt;/xsd:complexType&gt; &lt;/xsd:element&gt; &lt;xsd:element name="leaseInfo"&gt; &lt;xsd:complexType&gt; &lt;xsd:all&gt; &lt;!-- (optional) if you want to change the length of lease - default if 90 secs --&gt; &lt;!-- 可选， 如果你想更改租约的时间。 - 默认情况下90 秒。(该值会在下面会进行说明。) --&gt; &lt;xsd:element name="evictionDurationInSecs" minOccurs="0" type="xsd:positiveInteger"/&gt; &lt;/xsd:all&gt; &lt;/xsd:complexType&gt; &lt;/xsd:element&gt; &lt;xsd:simpleType name="dcNameType"&gt; &lt;!-- Restricting the values to a set of value using 'enumeration' --&gt; &lt;!-- 使用'enumeration'(枚举)将值限制为一组值 --&gt; &lt;xsd:restriction base = "xsd:string"&gt; &lt;xsd:enumeration value = "MyOwn"/&gt; &lt;xsd:enumeration value = "Amazon"/&gt; &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt; &lt;xsd:simpleType name="statusType"&gt; &lt;!-- Restricting the values to a set of value using 'enumeration' --&gt; &lt;!-- 使用'enumeration'(枚举)将值限制为一组值 --&gt; &lt;xsd:restriction base = "xsd:string"&gt; &lt;xsd:enumeration value = "UP"/&gt; &lt;xsd:enumeration value = "DOWN"/&gt; &lt;xsd:enumeration value = "STARTING"/&gt; &lt;xsd:enumeration value = "OUT_OF_SERVICE"/&gt; &lt;xsd:enumeration value = "UNKNOWN"/&gt; &lt;/xsd:restriction&gt; &lt;/xsd:simpleType&gt; &lt;xsd:complexType name="amazonMetdataType"&gt; &lt;!-- From &lt;a class="jive-link-external-small" href="http://docs.amazonwebservices.com/AWSEC2/latest/DeveloperGuide/index.html?AESDG-chapter-instancedata.html" target="_blank"&gt;http://docs.amazonwebservices.com/AWSEC2/latest/DeveloperGuide/index.html?AESDG-chapter-instancedata.html&lt;/a&gt; --&gt; &lt;xsd:all&gt; &lt;xsd:element name="ami-launch-index" type="xsd:string" /&gt; &lt;xsd:element name="local-hostname" type="xsd:string" /&gt; &lt;xsd:element name="availability-zone" type="xsd:string" /&gt; &lt;xsd:element name="instance-id" type="xsd:string" /&gt; &lt;xsd:element name="public-ipv4" type="xsd:string" /&gt; &lt;xsd:element name="public-hostname" type="xsd:string" /&gt; &lt;xsd:element name="ami-manifest-path" type="xsd:string" /&gt; &lt;xsd:element name="local-ipv4" type="xsd:string" /&gt; &lt;xsd:element name="hostname" type="xsd:string"/&gt; &lt;xsd:element name="ami-id" type="xsd:string" /&gt; &lt;xsd:element name="instance-type" type="xsd:string" /&gt; &lt;/xsd:all&gt; &lt;/xsd:complexType&gt; &lt;xsd:complexType name="appMetadataType"&gt; &lt;xsd:sequence&gt; &lt;!-- this is optional application specific name, value metadata --&gt; &lt;!-- 这是可选的应用专用名，值的元数据。 --&gt; &lt;xsd:any minOccurs="0" maxOccurs="unbounded" processContents="skip"/&gt; &lt;/xsd:sequence&gt; &lt;/xsd:complexType&gt;&lt;/xsd:schema&gt; evictionDurationInSecs：默认情况下Eureka Server会每隔60秒检测失效的服务，失效的服务是超过一定时间没有发送心跳进行续约的服务。这里的evictionDurationInSecs用来定义服务租约的超时时间。 该值定义在org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean#leaseExpirationDurationInSeconds表示eureka server至上一次收到client的心跳之后，等待下一次心跳的超时时间，在这个时间内若没收到下一次心跳，则将移除该instance，默认为90秒。 如果该值太大，则很可能将流量转发过去的时候，该instance已经不存活了。 如果该值设置太小了，则instance则很可能因为临时的网络抖动而被摘除掉。 该值至少应该大于leaseRenewalIntervalInSeconds 服务续约 示例 : PUT /eureka/v2/apps/MYAPP/i-6589ef612345Response:Status: 200 (on success)404 (eureka doesn&apos;t know about you, Register yourself first)500 (failure) 服务关闭/服务下线 (If Eureka doesn’t get heartbeats from the service node within the evictionDurationInSecs, then the node will get automatically de-registered )如果Eureka在服务租约超时时间内没有从服务节点获得心跳续约，那么服务节点将自动取消注册。 示例 : DELETE /eureka/v2/apps/MYAPP/i-6589ef6 1234Response:Status:200 (on success)500 (failure)]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Eureka</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多个SSH连接配置之HEXO部署]]></title>
    <url>%2F2017%2F08%2F20%2Fhexo-deploy-with-multiple-ssh-config%2F</url>
    <content type="text"><![CDATA[本文是给自己留个笔记，是建立在本人自己的思路上，所以有些地方不会说的那么详细如果只是来找直接的解决方案，可以参考《本地有多个github账号如何使用hexo部署到特定账号》这篇文章。 这里只针对Hexo部署时在多个SSH配置时一些处理，关于多个Github账号的搭配多个SSH配置的问题请自行谷歌了解。 多个SSH配置是指的是在用户家目录下.ssh\config文件中(C:\Users\good_boy\.ssh\config)文件中配置了多个SSH的连接。之前在《如何使用SSH配置文件进行SSH连接》已经介绍了多个SSH配置的配置方法。 但当我们这样子配置之后，会发现在Hexo部署的时候会出现错误。因为Hexo在提交到仓库的时候不知道使用哪个SSH配置。我们要解决的问题让仓库地址跟我们的SSH配置中的Host主机对应上，这样子他就会去找对应的SSH配置了。听起来可能不太明白，其实很简单。 例如现在我的电脑上有两个Github账号，然后SSH配置文件的连接配置为： 1234567891011Host github_1 User git HostName github.com PreferredAuthentications publickey IdentityFile C:/Users/good_boy/.ssh/keys/github_1Host github_2 User git HostName github.com PreferredAuthentications publickey IdentityFile C:/Users/good_boy/.ssh/keys/github_2 配置了多个SSH链接，这时候我们如果还是以git作为github.com这个主机的User去连接那么就会失败。 $ ssh -T git@github.comPermission denied (publickey). 这是因为不能确定具体要去使用哪个配置文件。这时候我们就需要指定具体的Host了，也就是你得通过ssh github_1这样子的方式来连接。 $ ssh -T github_1Hi good_boy! You’ve successfully authenticated, but GitHub does not provide shell access. 一般情况下，我们的Hexo配置文件_config.yml中Deploy部分配置如下： 1234deploy:- type: git repo: github: git@github.com:good_boy/good_boy.github.io.git 部署仓库的地址中有 `git@github.com这么一段，这就是SSH连接的用户名和主机。这样部署，当Hexo进行ssh通讯的时候就相当于ssh -T git@github.com` ，所以是会导致连接失败的。 解决方法就是把仓库SSH地址：`git@github.com:good_boy/good_boy.github.io.git中的git@github.com替换成对应的SSH配置的主机，冒号后面的就是Github的用户名，这个不需要改。 例如这里HEXO部署到的Github账号需要使用github_1这个SSH配置来进行SSH连接验证。 那么部署的仓库地址就需要写成：repo: github_1:good_boy/good_boy.github.io.git`这样子Hexo在部署进行SSH连接的时候就会知道使用哪个SSH配置了。 这样的做法也适用于部署到多个Git仓库，例如同时部署到了Github和Coding上，那么SSH连接配置和Hexo的配置就是下面这样子： SSH连接配置 1234567891011Host coding_good_boy User git HostName git.coding.net PreferredAuthentications publickey IdentityFile C:/Users/good_boy/.ssh/keys/coding_good_boyHost github_good_boy User git HostName github.com PreferredAuthentications publickey IdentityFile C:/Users/good_boy/.ssh/keys/github_good_boy Hexo部署配置 12345deploy:- type: git repo: coding: coding_good_boy:good_boy/good_boy.coding.me.git github: github_good_boy:good_boy/good_boy.github.io.git]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>SSH</tag>
        <tag>SSHConfig</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse配置所有工作空间默认文件编码]]></title>
    <url>%2F2017%2F08%2F18%2Fconfigure-default-file-encoding-for-all-workspace-of-eclipse%2F</url>
    <content type="text"><![CDATA[一般Eclipse创建新的工作空间时都需要手动指定一下编码，也就是File Encoding，这里分享的就是以配置文件的方式来指定所有的工作空间默认的编码。包括新建的工作空间也会生效。 方法很简单，在Eclipse安装目录，找到eclipse.ini使用文本编辑器打开（建议不要使用记事本）在最后一行加上 -Dfile.encoding=utf-8 即可，建议再加一个回车。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome主题背景图URL地址]]></title>
    <url>%2F2017%2F08%2F15%2Fchrome-theme-background-image-url%2F</url>
    <content type="text"><![CDATA[主题的背景图比较好看，提取出来做桌面壁纸。在Chrome地址栏输入：chrome://theme/IDR_THEME_NTP_BACKGROUND出来背景图右键另存为即可.]]></content>
      <categories>
        <category>Chrome</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页文本完全水平+垂直居中]]></title>
    <url>%2F2017%2F08%2F01%2Fweb-page-horizantal-and-vertical%2F</url>
    <content type="text"><![CDATA[实现方式1定义一个表格，并套上tr及td： 12345&lt;table css="table"&gt; &lt;tr&gt; &lt;td&gt;文本&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 加上css样式 12345678910.table &#123; width: 100%; height: 100%; position: absolute; top: 0; left: 0; text-align: center; /*vertical-align: middle;*/ /*The default value is middle can inherit from tbody tag, so it's not necessary.*/ &#125; 这个css样式的思路就是： 首先将table变成和浏览器窗口一样的大小。通过设置width: 100%; height: 100%; 其次设置text-align: center;让文本水平居中。 接着让它的position为absolute表示，让它的子元素相对于它来定位，同时我们设置top和left为0，这时候它现在的位置就是从浏览器左上角00的位置开始了，同时因为absolute的设置可以让它的子元素就是相对于浏览器的最上最左的位置进行定位。 最后我们其实可以设置一个vertical-align: middle;的样式，但是因为浏览器在处理table标签的时候会默认生成一个tbody标签，这个标签会自动有一个vertical-align: middle;样式，所以在tbody里面的tr和td元素会默认继承这个样式，所以这个样式我们就不用定义了。 实现方式2同实现方式1同样的css样式，html代码改为以下： 123&lt;div class="table" style="display: table"&gt; &lt;span style="display: table-cell; vertical-align: middle;"&gt;这是要居中的文本&lt;/span&gt;&lt;/div&gt; 方式2的实现思路就是将span应用display: table-cell样式后让其拥有和td一样的功能，就相当于将span变成了td元素，然后再通过vertical-align: middle;让其可以居中显示。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>table-cell</tag>
        <tag>postition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用SSH配置文件进行SSH连接]]></title>
    <url>%2F2017%2F06%2F14%2Fhow-to-use-ssh-config-file-for-a-ssh-connection%2F</url>
    <content type="text"><![CDATA[SSH配置文件可以方便我们进行一个SSH连接。而不用每次连接的时候都输入账号和密码。 不使用配置文件进行连接(使用命令行方式)那么我们在不使用配置文件的时候(使用命令行的方式)是如何建立连接的呢？ 用密码登录输入命令：ssh root@66.111.222.23 -p 27275 用密钥登录输入命令：ssh root@66.111.222.23 -p 27275 -i ~/VPS_SSH_KEY/66.111.222.23.pri通过-p参数指定端口(默认为22)，-i参数手动指定私钥的路径。 ~代表用户家目录，如果你电脑用户名为flix对Windows系统来说，用户家目录的路径就是C:\User\flix\对Linux系统来说就是/home/flix/ 使用配置文件方式登录(基于密钥)上面通过命令行的方式登录，麻烦的地方在于每次都要输入password或者私钥的passphrase，所以这里说一下SSH的配置文件方式来登录。 建立目录并创建文件首先在用户家目录里建立.ssh文件夹(如果没有创建该文件夹)，然后在.ssh文件夹里建立一个config文件。 Windows系统在新建.ssh文件夹时需要通过cmd命令来新建，在cmd窗口输入mkdir .ssh，然后再在.ssh文件夹中新建config文件。 Linux系统按照顺序输入下面3个命令：最后chmod为什么要输入，最下面的注意事项会说。 123mkdir ~/.sshtouch ~/.ssh/configchmod 600 ~/.ssh/config 编辑文件内容编辑config文件的内容，输入相关的配置：123456Host 66.vps HostName 66.111.222.23 Port 27275 User root PreferredAuthentications publickey IdentityFile ~/VPS_SSH_KEY/66.111.222.23.pri Windows系统用记事本编辑config文件。Linux系统输入命令vi ~/.ssh/config来进行编辑。上面的内容做一下说明，具体的配置你按照自己的配置进行替换，config文件中是用Host配置项来进行多个配置的分割。并用缩进符来进行一些子项配置。 Host后面的文本内容可以随意命名，起一个标识作用，用于区分多个Host HostName用于指定主机地址，可以是域名或者ip地址 Port用于指定主机端口，如果不写这一项默认端口为22 User指定主机的用户名，就是命令ssh root@66.111.222.23@前面的用户名 PreferredAuthentications 指定优先身份认证方式，由于我们是通过公私钥来与服务器进行验证交互，所以这里写publickey就行(默认是按照gssapi-with-mic,hostbased,publickey,keyboard-interactive,password这样的顺序来进行身份验证) IdentityFile就是指定私钥的路径 建立连接经过这样的配置之后我们就可以使用ssh 66.vps如此简单的命令来连接了。 1234567891011121314flix@flix-PC:~$ ssh 66.vpsEnter passphrase for key &apos;~/VPS_SSH_KEY/66.111.222.23.pri&apos;: Welcome to Ubuntu 16.04.2 LTS (GNU/Linux 4.4.0-79-generic x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage0 packages can be updated.0 updates are security updates.*** System restart required ***root@ubuntu:~# 这样子是不是简单多了。 配置多个Host我们也可以利用配置文件的方式来配置多个不同提供了SSH连接的主机。下面是2个Github配置以及一个Coding.net的配置。 1234567891011121314151617Host github1 HostName github.com User git PreferredAuthentications publickey IdentityFile ~/Git_SSH_KEY/github1.priHost github2 HostName github.com User git PreferredAuthentications publickey IdentityFile ~/Git_SSH_KEY/github2.pri Host coding HostName git.coding.net User git PreferredAuthentications publickey IdentityFile ~/Git_SSH_KEY/coding.pri 输入ssh -T github1测试连接是否成功。12flix@flix-PC:~$ ssh -T github1Hi flix! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 注意事项在Linux中，你的私钥文件，以及.ssh文件夹下的config文件，权限如果过于开放，那么在进行连接的时候会提示你Bad owner or permissions on ~/.ssh/config，目的是提醒你这些重要的文件你不应该对其他人开放较高的权限。解决这一问题的办法很简单。只需要降低文件权限即可。输入chmod 600 ~/.ssh/config只给予当前读写权限。私钥文件的权限也要这样设置。 123flix@flix-PC:~$ ls -l .ssh/config ~/Git_SSH_KEY/github.pri-rw------- 1 flix flix 462 6月 14 00:22 .ssh/config-rw------- 1 flix flix 1794 6月 11 14:50 ~/Git_SSH_KEY/github.pri 相关配置也许有的人会好奇config文件里都可以配置哪些东西，这里就不描述那么多了，你可以看一下命令手册：《ssh_cofig》，Linux系统直接man ssh_config。 其他SSH相关Git SSH Key 生成步骤：http://blog.csdn.net/hustpzb/article/details/8230454SSH密钥登录让Linux VPS/服务器更安全：https://www.vpser.net/security/linux-ssh-authorized-keys-login.html使用 SSH config 文件：http://daemon369.github.io/ssh/2015/03/21/using-ssh-config-file]]></content>
      <categories>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谷歌验证码jar包Kaptcha的使用和运行过程]]></title>
    <url>%2F2017%2F04%2F17%2Fgoogle-s-kaptcha-jar-usage-and-running-process%2F</url>
    <content type="text"><![CDATA[首先说一下使用方法, 然后下面说一下运行过程! 使用方法首先在web.xml中加入KaptchServlet 12345678&lt;servlet&gt; &lt;servlet-name&gt;Kaptcha&lt;/servlet-name&gt; &lt;servlet-class&gt;com.google.code.kaptcha.servlet.KaptchaServlet&lt;/servlet-class&gt;&lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;Kaptcha&lt;/servlet-name&gt; &lt;url-pattern&gt;/kaptcha.jpg&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 然后页面写一个form表单和一个验证码代码. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;%@ page language="java" contentType="text/html;charset=UTF-8" pageEncoding="UTF-8" %&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;验证码&lt;/title&gt;&lt;body&gt;&lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;img src="/kaptcha.jpg" id="kaptchaImage"&gt;&lt;/td&gt; &lt;td align="top"&gt; &lt;form method="POST"&gt; &lt;br&gt;验证码:&lt;input type="text" name="kaptchafield"&gt;&lt;br/&gt; &lt;input type="submit" name="submit"&gt; &lt;/form&gt; &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;% // 从session中获取验证码的值! String c = (String) session.getAttribute( com.google.code.kaptcha.Constants.KAPTCHA_SESSION_KEY); // 获取输入的验证码值! String parm = (String) request.getParameter("kaptchafield"); if ( c != null &amp;&amp; parm != null ) &#123; if ( c.equals(parm) ) &#123; out.println("&lt;b&gt;验证码正确&lt;/b&gt;"); &#125; else &#123; out.println("&lt;b&gt;验证码错误&lt;/b&gt;"); &#125; &#125;%&gt;&lt;!-- 引用Jquery之后再写这个代码就可以通过点击图片换验证码了. --&gt;&lt;script type="text/Javascript"&gt; $(function() &#123; $('#kaptchaImage').click(function () &#123; $(this).attr('src', '/kaptcha.jpg?' + Math.floor(Math.random()*100) ); &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 使用就是这么简单. 下面说一下运行流程. 运行过程建议使用开启debug后跟着下面的描述看一下运行流程. 这个框架是帮我们生成验证码用的, 验证码就是一个图片.那么在生成的时候肯定要请求一个地址, 通过这个地址返回一个图片.那么我们需要找到这个jar包用于生成验证码的servlet. 在 https://code.google.com/archive/p/kaptcha/wikis/HowToUse.wiki查看查看谷歌的wiki()之后, 发现需要配置com.google.code.kaptcha.servlet.KaptchaServlet这个servlet. 配置格式为: 12345678&lt;servlet&gt; &lt;servlet-name&gt;Kaptcha&lt;/servlet-name&gt; &lt;servlet-class&gt;com.google.code.kaptcha.servlet.KaptchaServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;Kaptcha&lt;/servlet-name&gt; &lt;url-pattern&gt;/kaptcha.jpg&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 好了, 这样在页面上再写一个img标签, 让src指向这个url-pattern里面的路径就可以拿到图片验证码了!&lt;img src=&quot;/kaptcha.jpg&quot;/&gt;由于url-pattern是自定义的, 所以可以换成别的也可以. 这样基本的就搞定了, 打开com.google.code.kaptcha.servlet.KaptchaServlet这个servlet看一下里面的源码, 发现就两个方法, 一个init初始化, 一个doget处理请求的方法. 12345678910111213141516171819@Overridepublic void init(ServletConfig conf) throws ServletException &#123; super.init(conf); // Switch off disk based caching. ImageIO.setUseCache(false); Enumeration&lt;?&gt; initParams = conf.getInitParameterNames(); while ( initParams.hasMoreElements() ) &#123; String key = (String) initParams.nextElement(); String value = conf.getInitParameter(key); this.props.put(key, value); &#125; Config config = new Config(this.props); this.kaptchaProducer = config.getProducerImpl(); this.sessionKeyValue = config.getSessionKey(); this.sessionKeyDateValue = config.getSessionDate();&#125; init方法就是通过servletconfig对象获取配置信息.获取了所有的初始化参数, 然后放到一个Properties对象中.然后把Properties对象传递过去, 创建Config对象, 1234public Config(Properties properties) &#123; this.properties = properties; this.helper = new ConfigHelper();&#125; 可以看到没做什么额外的事情.接下来config.getProducerImpl(), 获取一个验证码生成器对象. 1234567public Producer getProducerImpl() &#123; String paramName = Constants.KAPTCHA_PRODUCER_IMPL; String paramValue = this.properties.getProperty(paramName); Producer producer = (Producer) this.helper.getClassInstance(paramName, paramValue, new DefaultKaptcha(), this); return producer;&#125; 前两句就是获取配置文件里有没有通过kaptcha.producer.impl配置自定义的验证码生成器对象.this.helper.getClassInstance()就是通过ConfigHelper对象获取验证码生成器对象, 这里强转是干了一个向上转型的事!getClassInstance()这个方法就是判断有没有在servlet的初始化参数里配置自定义的验证码生成器, 没有的话就返回传递过去的new DefaultKaptcha()对象. 接下来到init方法里的this.sessionKeyValue = config.getSessionKey();这一段代码.这段代码是干嘛的呢, 作用就是看我们有没有在servlet里通过kaptcha.session.key配置用于给谷歌设置验证码值的session key初始化参数.如果没有就返回KAPTCHA_SESSION_KEY这个字符串作为session的key.可能大家不太理解为什么我这样说, 下面我会解释.然后执行this.sessionKeyDateValue = config.getSessionDate();, 这个代码和上一段代码类似, 就是去初始化参数里找kaptcha.session.date的值, 用于session的key, 如果初始化参数里没有那么让KAPTCHA_SESSION_DATE这个字符串作为session的key.这两个代码的作用一会我会解释. 执行完this.sessionKeyDateValue = config.getSessionDate();这段代码后, 整个com.google.code.kaptcha.servlet.KaptchaServlet的init方法完毕了, 也就是servlet的初始化完了. 不过这时候还没开始下发验证码, 那么上面时候下发呢.当然是KaptchaServlet这个servlet的dopost或者doget方法被调用的时候执行. 但KaptchaServlet只有一个doget方法, 不提供doPost方法的原因就在于img标签src属性发起的是一个get请求而不是post请求.所以聪明的google自然也没必要写一个多余的dopost了.那么当浏览器加载img标签, 检查到src属性, 发起了一个可爱的get请求之后, KaptchaServlet开始执行doGet方法.这个就是doGet的处理代码, 我们来研究一下. 12345678910111213141516171819202122232425262728293031323334@Overridepublic void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; // Set to expire far in the past. resp.setDateHeader("Expires", 0); // Set standard HTTP/1.1 no-cache headers. resp.setHeader("Cache-Control", "no-store, no-cache, must-revalidate"); // Set IE extended HTTP/1.1 no-cache headers (use addHeader). resp.addHeader("Cache-Control", "post-check=0, pre-check=0"); // Set standard HTTP/1.0 no-cache header. resp.setHeader("Pragma", "no-cache"); // return a jpeg resp.setContentType("image/jpeg"); // create the text for the image String capText = this.kaptchaProducer.createText(); // store the text in the session req.getSession().setAttribute(this.sessionKeyValue, capText); // store the date in the session so that it can be compared // against to make sure someone hasn't taken too long to enter // their kaptcha req.getSession().setAttribute(this.sessionKeyDateValue, new Date()); // create the image with the text BufferedImage bi = this.kaptchaProducer.createImage(capText); ServletOutputStream out = resp.getOutputStream(); // write the data out ImageIO.write(bi, "jpg", out);&#125; 前面那几行设置响应信息的代码就不看了. 12// create the text for the imageString capText = this.kaptchaProducer.createText(); 这个代码, 看注释就知道是创建用于验证码的文本. 就是验证码的文本内容. this.kaptchaProducer还记得这个值是啥吗?看名字是验证码生成器的意思, 这个值早在init方法加载的时就被赋值了.就是在com.google.code.kaptcha.util.Config#getProducerImpl这个方法里赋值的.上面我已经说过这个方法了, 就是返回了谷歌自己的默认验证码生成器对象: DefaultKaptcha然后this.kaptchaProducer.createText()就是调用DefaultKaptcha里面的createText()方法,就是创建了一个文本. 我这里简单的讲解下文本的创建过程.感兴趣的朋友可以自己看底层代码.底层代码在: com.google.code.kaptcha.impl.DefaultKaptcha#createText主要实现过程就是先检查KaptchaServlet初始化参数里有没有配置kaptcha.textproducer.impl的值, 这个是配置自定义的文本生成器. 如果没有配置就创建谷歌自己的 DefaultTextCreator(默认文本生成器)对象.调用createText()这个方法, 这个方法就是获取KaptchaServlet初始化参数为kaptcha.textproducer.char.length配置的一个字符串.这个参数就是配置生成的验证码的字母数, 也就是字符数量. 如果没有配置, 那么底层传递的默认值是5个!然后获取KaptchaServlet初始化参数中的kaptcha.textproducer.char.string配置的值, 这个配置就是生成验证码提供的字符串.底层就是通过将这个字符串转成char数组, 然后根据长度随机取出5个字符作为验证码. 如果不提供这个值, 底层自己提供了一个默认的字符串.这样就返回了验证码的文本. 这里提醒一下, 上面说到会获取初始化参数有没有配置kaptcha.textproducer.impl, 那么就是说我们可以通过实现TextProducer这个接口自己实现一个验证码文本生成器来生成自定义的文本.然后DefaultTextCreator对象是TextProducer的实现类, 还有ChineseTextProducer和FiveLetterFirstNameTextCreator 两个实现类, 英文好的同学这里就知道这2个实现类是干啥子的了.ChineseTextProducer 中文文本生成器, FiveLetterFirstNameTextCreator 以5个字母组成的人的名字生成器.这两个类就比较简单了, 直接是提供一个string数据, 内置了一些字符串, 然后随机取其中一个返回. 上面创建了验证码的文本, 到了下面的2个代码 1234567// store the text in the sessionreq.getSession().setAttribute(this.sessionKeyValue, capText);// store the date in the session so that it can be compared// against to make sure someone hasn't taken too long to enter// their kaptchareq.getSession().setAttribute(this.sessionKeyDateValue, new Date()); 上面给大家埋了一个关子, 就是在KaptchaServlet初始化的时候获取了2个sessionKey.这里来通过sessionKey往session里设置了刚才创建的验证码文本, 以及一个时间对象.具体的作用, 这2个代码的注释说了. 存储验证码文本到session中, 以及存储当前的时间到session里,然后存储当前时间可以依照这个来对比确保用户是不是过了很久才输入验证码.这个有啥用呢, 就是说谷歌给我们提供了一个验证码超时的时间, 然后我们从session中获取这个key, 然后根据这个时间写一个判断是不是要让验证码失效. 因为我们有时候会需要让验证码失效的功能, 如果在一定的时间内没有输入.至于第一个那个设置验证码文本到session中就是让我们更好的获取验证码的值来判断用户输入的是不是对的验证码.比如我们在jsp中就可以写一个判断验证码对不对, 然后再决定要不要提交表单! 剩下的3行代码没什么好说的了, 底层的东西了, 设计到什么画图啊2d啊的东西, 本人还不懂, 就暂时不介绍了, 感兴趣的朋友自己研究吧.主要就是把文本弄到一个图片上, 然后发送给浏览器. 1234567// create the image with the textBufferedImage bi = this.kaptchaProducer.createImage(capText);ServletOutputStream out = resp.getOutputStream();// write the data outImageIO.write(bi, "jpg", out); 上面说了一堆, 其实还有很多地方没有说, 但这些已经差不多就是主要的流程了.其他的特别细致的地方这里就不再说明. 简单说一下, 首先我们配置KaptchaServlet, 然后写一个url-pattern.然后读取我们配置在Servlet中的初始化参数来生成验证码.在生成验证码的时候会把验证码放到session中, session的key就是我们通过kaptcha.session.key配置的值.如果没有配置那么session的key就是KAPTCHA_SESSION_KEY. 然后我们可以通过key来获取验证码的值, 来进行判断验证码是否正确! 补充: 上面说的很多可以在KaptchaServlet初始化参数中配置的东西, 可以在com.google.code.kaptcha.Constants这个类中看到.定义了很多常量, 用于配置生成验证码的参数! 下面是整理的一些参数的意思: 配置项 默认值 说明 kaptcha.border yes 验证码图片的边框，可以设置yes或者no kaptcha.border.color black 边框的颜色reg值。合法值 rgb，black，blue，white kaptcha.border.thickness 1 边框的厚度 kaptcha.image.width 200 图片的宽度 kaptcha.image.height 50 图片的高度 kaptcha.producer.impl com.google.code.kaptcha.impl.DefaultKaptcha 验证码生成器实现类, 可以实现Producer接口自定义一个! kaptcha.textproducer.impl com.google.code.kaptcha.text.impl.DefaultTextCreator 生成验证码文字的实现类, 具体我上面描述过了. kaptcha.textproducer.char.string abcde2345678gfynmnpwx 验证码中使用的字符 kaptcha.textproducer.char.length 5 验证码中字符的数量 kaptcha.textproducer.font.names Arial, Courier 验证码的字体 kaptcha.textproducer.font.size 40 字体的大小 kaptcha.textproducer.font.color black 字体颜色 rgb值，颜色单词 kaptcha.textproducer.char.space 2 两个字符之间的间距 kaptcha.noise.impl com.google.code.kaptcha.impl.DefaultNoise 干扰线生成类 kaptcha.noise.color black 干扰线颜色 kaptcha.obscurificator.impl com.google.code.kaptcha.impl.WaterRipple(水波效果) 模糊迷惑器的实现类.用于干扰验证码的识别! kaptcha.background.impl com.google.code.kaptcha.impl.DefaultBackground 背景颜色设置类 kaptcha.background.clear.from light grey 渐变颜色 左到右 kaptcha.background.clear.to white 渐变颜色 右到左 kaptcha.word.impl com.google.code.kaptcha.text.impl.DefaultWordRenderer 文本渲染器 kaptcha.session.key KAPTCHA_SESSION_KEY 配置获取验证码的sessionKey kaptcha.session.date KAPTCHA_SESSION_DATE 配置获取验证码生成的时间的session key.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>验证码Jar包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遍历List集合时出现的3种异常]]></title>
    <url>%2F2017%2F04%2F10%2Fthree-exception-will-be-happenning-when-interaotr-a-list%2F</url>
    <content type="text"><![CDATA[参考:http://blog.csdn.net/izard999/article/details/6708738http://bbs.itheima.com/thread-41997-1-1.html 异常1异常: java.util.ConcurrentModificationException (并发修改异常) link: http://bbs.itheima.com/thread-41997-1-1.html 此贴描述了第一种异常.当我们在使用foreach这个增强型for循环遍历List时, 除了System.out.println();打印可以之外, 其他add, remove等操作会发生异常(执行set方法不会抛出异常). 1234567891011121314151617181920212223242526272829303132public class AAA &#123; // 要求： 查找集合中有没有zhangsan这个字符串。如果有，则再添加一个lisi进去。 public static void main (String[] args) &#123; // 创建集合对象 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("zhaoliu"); list.add("zhangsan"); list.add("wangwu"); // 普通for循环 for ( int x = 0; x &lt; list.size(); x++ ) &#123; String s = list.get(x); if ( "zhangsan".equals(s) ) &#123; list.add("lisi"); &#125; &#125; System.out.println("list:" + list); System.out.println("******************************************"); //增强for循环 for ( String s : list ) &#123; if ( "zhangsan".equals(s) ) &#123; list.add("lisi"); &#125; &#125; System.out.println("list:" + list); &#125;&#125; 如上代码在增强for循环遍历时执行add方法会抛出 1234D:\Java\jdk1.8.0_112\bin\java java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901) at java.util.ArrayList$Itr.next(ArrayList.java:851) ConcurrentModificationException翻译为: 并发修改异常.这就代表同时发生了一个操作.那么借由上面链接中的帖子来解释说在使用foreach遍历的时候, 其实是通过一个迭代器进行迭代, 而在迭代的过程中不允许对List集合进行增删之类的操作.下面是发生其异常的原因, 也可以参考: http://bbs.itheima.com/forum.php?mod=viewthread&amp;tid=41997&amp;page=1&amp;authorid=75804 这里的解释. 12at java.util.AbstractList$Itr.checkForComodification(Unknown Source)at java.util.AbstractList$Itr.next(Unknown Source) java.util.AbstractList$Itr 中$符号后面的Itr表示Itr是AbstractList中的一个内部类. 在AbstractList$Itr这个类中实现了Iterator接口，当使用增强的for循环时，应该是使用迭代器进行迭代了，如果你在这期间使用了add或remove方法的话，在ArrayList类中执行了这样的代码 1234567891011121314151617181920public boolean add(E e) &#123; ensureCapacity(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; add方法中调用了ensureCapacity方法. 123456789101112public void ensureCapacity(int minCapacity) &#123; modCount++; int oldCapacity = elementData.length; if (minCapacity &gt; oldCapacity) &#123; Object oldData[] = elementData; int newCapacity = (oldCapacity * 3)/2 + 1; if (newCapacity &lt; minCapacity) newCapacity = minCapacity; // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125;&#125; add和remove方法都引起了AbstractList$Itr中的modCount属性增加值，然后当下一次遍历List, 迭代器调用next方法时调用了checkForComodification()方法. 1234567891011public E next() &#123; checkForComodification(); try &#123; E next = get(cursor); lastRet = cursor++; return next; &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125;&#125; 但checkForComodification()方法进行了modeCount和expectedModCount(翻译为: 预期修改次数)判断, 发现不一致, 所以抛出了异常. 12345final void checkForComodification() &#123; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125; 异常2异常: java.lang.IllegalStateException (非法状态异常)情景如下: 我们知道Arrays.asList(T ... t);可以将一个数组变成一个List.代码如下: 12345678@Test public void testRemove () &#123; List&lt;String&gt; list = Arrays.asList("fd", "fds", "2341f"); Iterator&lt;String&gt; it = list.iterator(); while ( it.hasNext() ) &#123; it.remove(); &#125;&#125; 在执行到it.remove();时会触发异常.首先Arrays.asList(&quot;fd&quot;, &quot;fds&quot;, &quot;2341f&quot;);会返回一个List, 那么这个List是什么类型呢? 通过查看源代码可以发现 123public static &lt;T&gt; List&lt;T&gt; asList(T... a) &#123; return new ArrayList&lt;&gt;(a);&#125; 看起来没什么问题, 但是这里有必要说明一下, 此ArrayList非java.util.ArrayList这个ArrayList. what??? 难道还有两个ArrayList, 是的.. 那么我们看一下这个ArrayList到底是哪里的, Ctrl + T按下发现这里的ArrayList原来是Arrays这个类中维护的一个内部类, 当然他也是继承自AbstractListwtfuck…jdk大佬真会玩. 但此ArrayList中并没有提供Iterator()方法, 所以调用Iterator方法还是执行的父类AbstractList中的Iterator方法, 在java.util.AbstractList$Itr中我们可以看到next和remove方法. 12345678910111213141516171819202122/** * Index of element returned by most recent call to next or * previous. Reset to -1 if this element is deleted by a call * to remove. */int lastRet = -1;public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; AbstractList.this.remove(lastRet); if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException e) &#123; throw new ConcurrentModificationException(); &#125;&#125; 由于这里的lastRet 初始值为-1, 所以执行remove方法时触发异常. 异常3异常: java.lang.UnsupportedOperationException (不支持的操作异常)代码如下: 1234567891011public void testRemove () &#123; List&lt;String&gt; list = Arrays.asList("fd", "fds", "2341f"); Iterator&lt;String&gt; it = list.iterator(); while ( it.hasNext() ) &#123; String s = it.next(); if ( "fd".equals(s) ) &#123; it.remove(); &#125; &#125;&#125; 这里同样是使用java.util.AbstractList$Itr迭代器进行获取. 但为什么和上面的情况不一样呢, 也就是为什么没有触发java.lang.IllegalStateException异常, 原因是因为我们在remove之前调用了next()方法, 改变了lastRet的值, 绕过了remove方法前面的if判断. 12345678910111213141516171819202122232425262728293031323334353637383940/** * Index of element to be returned by subsequent call to next. */int cursor = 0;/** * Index of element returned by most recent call to next or * previous. Reset to -1 if this element is deleted by a call * to remove. */int lastRet = -1;public E next() &#123; checkForComodification(); try &#123; int i = cursor; // i 为0 E next = get(i); lastRet = i; // lastRet接收i的赋值后变成了0. cursor = i + 1; return next; &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125;&#125;public void remove() &#123; if (lastRet &lt; 0) // 所以判断不成立, 跳出下面的异常 throw new IllegalStateException(); checkForComodification(); try &#123; AbstractList.this.remove(lastRet); if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException e) &#123; throw new ConcurrentModificationException(); &#125;&#125; 12if (lastRet &lt; 0) throw new IllegalStateException(); 当跳出这个判断后, 执行AbstractList.this.remove(lastRet);这一句的时候, this代表是迭代器也就是java.util.AbstractList$Itr, 这里的remove方法是java.util.AbstractList#remove中的方法, 这个方法什么也没做, 直接抛出了一个异常. 因此上面的代码抛出异常. 123public E remove(int index) &#123; throw new UnsupportedOperationException();&#125; 总结三种异常都发生在迭代器之上.其中第一种最常见, 也是最容易犯的一种.原因在于一边在遍历, 一边在修改, 导致底层实现代码出现错误, 从而出现异常. 第二和第三则在于Arrays.asList()方法所产生的ArrayList并不是java.util.ArrayList, 而是Arrays内部类中的ArrayList. 而这个内部ArrayList是没有覆盖父类java.util.AbstractList的add和remove方法的(但覆盖了set get, 所以这2个方法不受影响), 所以不管是通过获取这个List的迭代器来进行remove(迭代器没有提供add方法)操作(上面说了迭代器最后调用remove方法还是java.util.AbstractList提供的方法), 还是调用这个List本身继承过来的add/remove方法进行操作, 最后都是调用的父类中的方法, 而父类中的方法, 就只有一行抛出异常的代码. 所以会发生异常. 我们在开发时, 只需要记住. 在通过迭代器的方法遍历集合时不要对其进行remove和add操作就可以了. 至于set方法是可以的. 其它有的公司面试时会问到这样的问题, 所以这里记录一下分享给大家, 也算是本人一个学习记录分享. 面试的时候先看面试给你的是通过Arrays.asList()方式获取的集合还是直接new ArrayList()的方式, 如果是前者, 那么可以使用 google上对怎么解决ConcurrentModificationException的方案已经很多, 例如用Collections.synchronizedCollection() 去同步集合, 但是这样可能会影响效率, JDK5之后concurrent包里面有个CopyOnWriteArrayList, 这个集合迭代的时候可以对集合进行增删操作, 因为迭代器中没有checkForComodification! 这种方式进行删除, 其次不管是增强型for遍历还是普通for遍历都不可以删除, 因为前者的ArrayList是调用的父类中的remove方法, 会抛出不支持操作异常.如果是后者, 那么可以你关心的就是遍历的时候是否通过迭代器的方式, 也就是增强型for循环, 如果是普通for遍历方式, 我想面试官不会问你 - -. 如果是增强型for, 那么就回答不可以, 会抛出并发操作异常.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>异常</tag>
        <tag>迭代器</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多态中的虚方法调用]]></title>
    <url>%2F2017%2F02%2F19%2Fvirtual-method-invoke-in-java%2F</url>
    <content type="text"><![CDATA[今天偶然看到这个东西, 想起来以前学的时候有点绕糊, 这里随笔记一下吧. 个人认为虚方法的调用发生在多态中.例如以下两个类, 一个是Employee, 一个是Programmer 类: Employee 1234567891011121314151617public class Employee &#123; protected int salary; protected int age; protected String name; public void showInfo() &#123; System.out.println("Employee中的showInfo方法"); System.out.println("姓名: " + this.getName() + ", 年龄: " + this.getAge() + ", 工资: " + this.getSalary()); System.out.println(); &#125; /** * 以下getter setter方法省略 */&#125; 类Programmer:123456789public class Programmer extends Employee &#123; @Override public void showInfo() &#123; System.out.println("Programmer中的showInfo方法" + "\n"); System.out.println("姓名: " + this.getName() + ", 年龄: " + this.getAge() + ", 工资: " + this.getSalary()); &#125;&#125; 通过这两个类我们知道Programmer是Employee的子类, 所以拥有其中所有的方法, 包括我们重写的showInfo方法以及未重写的getter和setter方法. 然后我们再来看下这个代码来了解一下在多态的情况下, 以不同的实例对象调用重写的方法会发生什么情况:12345678910111213141516public class TestVitrualMethodInvoke &#123; public static void main(String[] args) &#123; Programmer programmer = new Programmer(); programmer.setAge(23); programmer.setName("张三"); programmer.setSalary(8000); Employee employee = new Programmer(); employee.setAge(30); employee.setName("李四"); employee.setSalary(5000); programmer.showInfo(); employee.showInfo(); &#125;&#125; 首先我们new了2个Programmer, 但用不同的引用接收. 分别是Employee和Programmer引用.我们知道: Employee employee = new Programmer();这段代码是一个多态的写法, 就是父类的引用接收子类的实例对象. 概念: 当父类的引用接收子类的实例对象时, 这时候调用重写的方法, 实际上调用的是重写后的方法, 也就是调用子类的方法, 虽然用于接收实例对象的引用是父类类型. 下面是输出结果:Programmer中的showInfo方法姓名: 张三, 年龄: 23, 工资: 8000 Programmer中的showInfo方法姓名: 李四, 年龄: 30, 工资: 5000 两次输出都是子类中被重写的方法.这就是多态中的虚方法调用, 所以我们在今后的开发中需要注意这点.如果我们想调用非子类中重写的方法, 那么就需要用父类的实例对象.或者我们在子类中可以使用super.showInfo()这种方式来调用. 补充说明: jvm在执行这两段代码时是这样工作的.12Employee employee = new Programmer();employee.showInfo(); 首先编译期间先检查Employee中有无showInfo方法, 若无则无法编译通过.然后在运行期间, 发现这个employee的实际引用的实例对象是Programmer, 所以就去调用Programmer中showInfo()方法, 这就是造成 上述现象的原因.所以我们说多态的对象只有在运行期才可以确定.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>虚方法</tag>
        <tag>多态</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML图片预览及AJAX上传]]></title>
    <url>%2F2017%2F01%2F02%2Fimage-preview-and-ajax-image-upload%2F</url>
    <content type="text"><![CDATA[图片上传前预览，然后ajax上传到服务器一个简单的实现. 用CSS做了一些界面上的处理，预览是用HTML5中的File和FileRead对象来实现(具体看下文代码注释中描述)，AJAX上传部分主要用到了FormData对象，该对象的作用就是可以让AJAX来异步上传一个二进制文件。后端的处理代码用到是Servlet中提供的两个框架，分别是: commons-fileupload-1.3.1.jar和commons-io-2.4.jar，可以在: http://archive.apache.org/dist/commons/ 下载到这2个jar包. 下面的实现代码中，会对CSS，JS，以及后端的Java部分进行说明，相关的HTML5对象会提供详细的文档链接。 最后推荐大家 Web API 接口一览表: https://developer.mozilla.org/zh-CN/docs/Web/API 这个地方。理由是：当使用Javascript编写网页代码时，有很多API可以使用并提供相关的示例代码。 前台界面及处理代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;AJAX图片上传&lt;/title&gt; &lt;style&gt; body &#123; color: #333; &#125; p.title &#123; font-size: 30px; width: 500px; hegith: auto; padding-left: 10px; border-left: 5px solid dodgerblue; &#125; div.big，div.middle，div.small &#123; display: inline-block; margin-right: 10px; &#125; .big img.avatar &#123; width: 200px; height: 200px; &#125; .middle img.avatar &#123; width: 100px; height: 100px; &#125; .small img.avatar &#123; width: 50px; height: 50px; &#125; .desc &#123; color: #999; &#125; .wrapper &#123; position: relative; &#125; .wrapper input &#123; width: 130px; height: 38px; cursor: pointer; &#125; .wrapper .portrait-filebtn &#123; outline: none; border: none; padding: 0; background: url("https://ss1.bdstatic.com/5KZ1bjqh_Q23odCf/static/princess/img/setportrait_btn_da8845e1.png") no-repeat 0 0px; &#125; .wrapper .portrait-file &#123; opacity: 0; position: absolute; left: 0; top: 0; &#125; div#info &#123; padding: 10px 0; font-size: 15px; &#125; &lt;/style&gt; &lt;script type="text/Javascript"&gt; window.onload = function () &#123; var fileInput = document.getElementById("fileImg"); var infoDiv = document.getElementById("info"); var avatarImgs = document.getElementsByClassName("avatar"); // 为文件选择input绑定一个change事件监听. fileInput.addEventListener("change", function (event) &#123; /** * 所以这里的this指针是input对象 * this.files获取的是WEB_API中的FileList对象。 * 参考: https://developer.mozilla.org/zh-CN/docs/Web/API/FileList * */ var file = this.files[0]; // 获取文件的大小且四舍五入后不保留小数。 var fileSize = (file.size / 1024).toFixed(); // 获取文件名 var fileName = file.name; infoDiv.innerHTML = "&lt;b&gt;Size: &lt;/b&gt;" + fileSize + "Kib&lt;br /&gt;" + "&lt;b&gt;Name: &lt;/b&gt;" + fileName; /** * WEB_API FileReader对象，参考: https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader */ var fileReader = new FileReader(); /** * 开始读取指定的File对象中的内容。 * 将File对象中的文件内容读入到FileReader对象result属性中。 * 关于这个方法的介绍推荐大家阅读: https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader */ fileReader.readAsDataURL(file); // 当fileReader载入的时候，我们把读入的数据给下面我们定义的img标签的src属性中。 fileReader.onload = function (event) &#123; // 我这里循环是因为我弄了3种尺寸的预览图. for (var i = 0; i &lt; avatarImgs.length; i++) &#123; var avatarImg = avatarImgs[i]; /** * 上面说了读入的会把File对象的文件内容读到result属性， * 所以这里获取result的值赋给img标签的src属性，就可以实现在上传前图片预览的功能了。 * * 这里的result指的是: 读取到File对象中的图片文件内容。 * 这个属性中的值的格式就是一个经过base64编码的图片数据URL。 * 差不多就是这样的格式，应该都见过的。 * data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEBLAEsAAD/7R+KUGhvdG9zaG9wIDMuMAA4QklNBAQAAAAAADwcAVo * * 了解更多请看: https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader/result */ avatarImg.src = this.result; //avatarImg.src = event.target.result; &#125; // ajax发送请求上传文件. ajaxSaveToServer(file); &#125; &#125;，false); &#125;; // AJAX上传 function ajaxSaveToServer(imgFile) &#123; var xhr = new XMLHttpRequest(); xhr.open("post", "saveImg"，true); /** * XMLHttpRequest Level 2添加了一个新的接口FormData。 * 利用FormData对象，我们可以通过Javascript用一些键值对来模拟一系列表单控件， * 我们还可以使用XMLHttpRequest的send()方法来异步的提交这个"表单"。 * 比起普通的ajax，使用FormData的最大优点就是我们可以异步上传一个二进制文件。 * * 上面的解释很清楚了，更多信息可以参考这里: https://developer.mozilla.org/zh-CN/docs/Web/API/FormData */ var formData = new FormData(); /** * 给当前FormData对象添加一个键/值对。 */ formData.append("img"，imgFile); // 后面的就是发送请求处理响应了。 xhr.send(formData); xhr.onreadystatechange = function () &#123; var state = xhr.readyState; var status = xhr.status; if (state == 4 &amp;&amp; status == 200) &#123; alert(xhr.responseText); &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;p class="title"&gt;Choose Image&lt;/p&gt; &lt;div class="wrapper"&gt; &lt;input type="button" class="portrait-filebtn" value="Choose"&gt; &lt;input type="file" class="portrait-file" name="file" id="fileImg" accept=".jpg,.png,.gif,.bmp,.jpeg"&gt; &lt;span class="pass-portrait-msg"&gt;Supporting formats: jpg、jpeg、gif、png、bmp&lt;/span&gt; &lt;/div&gt; &lt;div id="info"&gt; &lt;/div&gt; &lt;p class="title"&gt;Image Preview&lt;/p&gt; &lt;div class="preview"&gt; &lt;div class="big"&gt; &lt;p class="desc"&gt;200x200 Pixel&lt;/p&gt; &lt;img src="" class="avatar"&gt; &lt;/div&gt; &lt;div class="middle"&gt; &lt;p class="desc"&gt;100x100 Pixel&lt;/p&gt; &lt;img src="" class="avatar"&gt; &lt;/div&gt; &lt;div class="small"&gt; &lt;p class="desc"&gt;50x50 Pixel&lt;/p&gt; &lt;img src="" class="avatar"&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 上面在注释里js和WEB_API的介绍说完了，这里说一下css代码相关的地方。首先。class为wrapper的div，需要设置position为relative，然后将里面的第二个input，也就是文件选择的input。它的position设置为absolute，absolute会相关于第一个position为非static的父元素来定位。所以这里就是相对于刚才那个class为container的div来定位，然后我们让它left和top都为0，让它紧贴着div，然后再给它的透明度设置为0，通过opacity: 0;来设置。这样子做了之后他前面的类型为button的input就会”覆盖”它，说是覆盖其实是因为透明度为0，人的眼睛看不到了。但是在页面上还是存在，所以我们不能设置display为none这个样式。因为我们需要能点击它。 其他的css就是我个人的一些处理，没什么特别的地方。 再然后我们来看服务端java代码，我用的servlet配合2个jar包来实现上传。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package com.xxxx.servlet;import org.apache.commons.fileupload.FileItem;import org.apache.commons.fileupload.FileUploadException;import org.apache.commons.fileupload.disk.DiskFileItemFactory;import org.apache.commons.fileupload.servlet.ServletFileUpload;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.File;import java.io.IOException;import java.io.PrintWriter;import java.util.Arrays;import java.util.List;public class SaveFile extends HttpServlet &#123; // 文件上传路径 private static final String UPLOAD_DIRECTORY = "upload"; // 文件路径分隔符，linux为/，windows为\ private static final String File_SEPARATOR = File.separator; // 允许的文件contentype类型. private static final String[] ALLOWED_TYPE = &#123; "image/jpg"，"image/jpeg"，"image/png"，"image/gif"，"image/bmp" &#125;; /** * 检查是否为允许的文件类型。 * * @param contentType * @return */ private boolean checkContentype (String contentType) &#123; if ( contentType == null ) return false; // 将数组转成list. List&lt;String&gt; list = Arrays.asList(ALLOWED_TYPE); // 查看是否存在于list中，如果有任意一个存在，那么就是合法的类型，否则就是不合法的。 return list.contains(contentType); &#125; protected void doPost (HttpServletRequest request，HttpServletResponse response) throws ServletException，IOException &#123; request.setCharacterEncoding("utf-8"); response.setContentType("text/html;charset=utf-8"); PrintWriter writer = response.getWriter(); try &#123; // 如果不是二进制文件，那么上传失败。 if ( !ServletFileUpload.isMultipartContent(request) ) &#123; writer.write("上传失败"); return; &#125; DiskFileItemFactory factory = new DiskFileItemFactory(); ServletFileUpload fileUpload = new ServletFileUpload(factory); List&lt;FileItem&gt; fileItems = fileUpload.parseRequest(request); FileItem fileItem = fileItems.get(0); String contentType = fileItem.getContentType(); if ( !checkContentype(contentType) ) &#123; writer.write("非法文件，请选择正确的图片文件"); return; &#125; // 获取上传文件的文件夹真实的物理路径。 String uploadPath = getServletContext().getRealPath(File_SEPARATOR + UPLOAD_DIRECTORY); File uploadPathFile = new File(uploadPath); // 文件夹不存在则创建文件夹. if ( !uploadPathFile.exists() ) &#123; uploadPathFile.mkdir(); &#125; // 获取文件名. String name = fileItem.getName(); // 如果文件名是完整的路径形式(火狐浏览器会存在这个现象)，那么截取出文件名。 if ( name.contains(File_SEPARATOR) ) &#123; name = name.substring(name.lastIndexOf(File_SEPARATOR) + 1); &#125; // 文件夹 + 文件名 File imgFile = new File(uploadPath + File_SEPARATOR + name); fileItem.write(imgFile); // 删除临时文件，这个方法也可以不调，因为在FileItem对象实例被回收的时候会自动清空临时文件，但框架注释说了，为了确保万一最好调用一下。 fileItem.delete(); if ( imgFile.exists() ) &#123; writer.write("上传成功!"); &#125; &#125; catch ( FileUploadException e ) &#123; e.printStackTrace(); &#125; catch ( Exception e ) &#123; e.printStackTrace(); &#125; finally &#123; writer.flush(); writer.close(); &#125; &#125; protected void doGet (HttpServletRequest request，HttpServletResponse response) throws ServletException，IOException &#123; doPost(request，response); &#125;&#125; 到此就结束了。没什么技术含量，主要是我写来玩的，同时也只用于参考。大家可以看一下上面用的几个HTML5 API对象来了解更多，以便按照自己的需求来开发。 这里推荐大家阅读张鑫旭的一篇相关博文以获得更多相关的知识《基于HTML5的可预览多图片Ajax上传》]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Ajax</tag>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS拖拽图片简单例子]]></title>
    <url>%2F2017%2F01%2F01%2Fjs-drag-drop-image-small-example%2F</url>
    <content type="text"><![CDATA[Reference: http://w3schools.bootcss.com/jsref/dom_obj_event.html 在H5中所有的元素都是可以被拖拽的, 通过给元素添加draggable=&quot;true&quot;属性. 相关的地方: ondragover 事件发生在: 元素拖拽到拖放的目标元素之上时.(事件处理程序多次调用) ondragstart 事件发生在: 元素开始拖拽之时(事件处理程序1次调用) ondrop 事件发生在: 被拖拽的元素完成拖放到目标元素盒子区域这一动作.(事件处理程序1次调用) 事件的默认行为, 比如说在复选框上点击按钮会发生选中或取消选中事件. 这里需要在ondragover事件里阻止浏览器默认打开的行为. dataTransfer对象. 在进行拖放操作时，进行数据的存储, 这个对象也保存了拖拽元素的数据. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;JS拖拽图片简单例子&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; .drop-target &#123; border: 1px solid black; width: 300px; height: 300px; &#125; img#img &#123; width: 200px; height: 200px; &#125; &lt;/style&gt; &lt;script type=&quot;text/Javascript&quot;&gt; function allowDrop(e) &#123; e.preventDefault(); &#125; function dragStart(event) &#123; var dataTransfer = event.dataTransfer; dataTransfer.setData(&quot;id&quot;, event.target.id); &#125; function drop(event) &#123; var dataTransfer = event.dataTransfer; var imgId = dataTransfer.getData(&quot;id&quot;); var img = document.getElementById(imgId); var div = event.target; div.appendChild(img); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=&quot;drop-target&quot; ondragover=&quot;allowDrop(event)&quot; ondrop=&quot;drop(event)&quot;&gt;请将图片拖放到这里来.&lt;/div&gt;&lt;img id=&quot;img&quot; ondragstart=&quot;dragStart(event)&quot; src=&quot;https://ooo.0o0.ooo/2017/08/20/599865a851d49.png&quot; draggable=&quot;true&quot;&gt;&lt;/body&gt;&lt;/html&gt; 在ondragstart那里获取图片的id属性值, 然后在drop方法里获取属性值获取图片对象, 接着添加到div里即可. 在ondragover事件里做处理操作, 让div取消默认行为, 接受图片的放入. 另外, event对象的两次target分别是被拽放对象img和拖放接受对象div.]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS获取项目路径]]></title>
    <url>%2F2016%2F12%2F25%2Fjs-get-project-path%2F</url>
    <content type="text"><![CDATA[写程序的时候在JS里面需要用到项目路径, 所以网上找了个例子, 然后看了下, 差不多如下. 123456789101112131415161718192021222324252627282930function getRootPath() &#123; // 获取主机地址, 如: http://example.com:8080 var hostPath = document.location.origin; /** * 获取URL中路径部分. * * 假设当前的URL是: http://example.com:8080/project_name/test.html * 返回: /project_name/test.html */ var pathName = document.location.pathname; /**********************获取项目名****************************/ var str = pathName.substr(1); // 返回: project_name/test.html var index = str.indexOf('/'); // 获取/所在的位置. /** * 从 /project_name/test.html 截取项目名 * 这里加上1是因为index是在str的位置, 也就是在project_name/test.html中的位置 * 而这时候的截取是从/project_name/test.html这里开始的, 多了个长度, 所以要加上1. */ var projectName = pathName.substring(0, index + 1); /** * 上面的三步可以直接这么写. * var projectName = pathName.substring(0, pathName.substr(1).indexOf('/') + 1); */ return hostPath + projectName;&#125; 代码还是比较通用的, 主要利用document.location.pathname; 获取路径地址, 然后截取出项目名. 适用于下面2种情况: 如果路径没有项目名: http://example:8080/test.html那么返回的是http://example:8080 如果路径带了项目名: http://example:8080/project_name/test.html那么返回的是: http://example:8080/project_name 如果路径没有项目名时, 是这样的情况: 123var str = pathName.substr(1); //这里获取到的是test.html var index = str.indexOf('/'); // 这里返回-1.var projectName = pathName.substring(0, index + 1); // 这里截取到的是空字符串. 而如果路径带了项目名, 我在上面代码注释里已经写了步骤介绍了过程. 这里就不再啰嗦了. 另外说一下, 网上的例子在获取主机路径的时候是这样的写法. 12345678// 先拿到当前页面的地址.var currentPagePath = document.location.href;// 然后获取URL中路径部分.var pathName = document.location.pathname;// 接着根据pathName在整个路径中的位置截取获取到主机路径.var hostPath = currentPagePath.substring(0, currentPagePath.indexOf(pathName); 但是我debug的时候发现document.location里面有一个origin属性(查了国内w3c并没有这个属性的介绍), 这个属性值就是主机的路径. 所以省的我们自己计算了, 同时我也测试过在带项目路径和没有项目路径这2种情况下, origin属性都是可以拿到主机路径的. 英文的W3C Location对象介绍页面有Origin这个属性: http://w3schools.bootcss.com/jsref/prop_loc_origin.html]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我是一个线程(修订版)]]></title>
    <url>%2F2016%2F12%2F25%2Fi-am-a-thread%2F</url>
    <content type="text"><![CDATA[第一回 初生牛犊我是一个线程，我一出生就被编了个号：0x3704，然后被领到一个昏暗的屋子里，在这里我发现了很多和我一模一样的同伴。我身边的同伴0x6900 待的时间比较长，他带着沧桑的口气对我说：“我们线程的宿命就是处理包裹。把包裹处理完以后还得马上回到这里，否则可能永远回不来了。”我一脸懵懂，“包裹，什么包裹？”“不要着急，马上你就会明白了，我们这里是不养闲人的。”果然，没多久，屋子的门开了， 一个面貌凶恶的家伙吼道：“0x3704 ,出来！”我一出来就被塞了一个沉甸甸的包裹，上面还附带着一个写满了操作步骤的纸。“快去，把这个包裹处理了。”“去哪儿处理？”“跟着指示走，先到就绪车间。”果然，地上有指示箭头，跟着它来到了一间明亮的大屋子，这里已经有不少线程了，大家都很紧张，好像时刻准备着往前冲。我刚一进来，就听见广播说：“0x3704，进入车间。”我赶紧往前走，身后有很多人议论。“他太幸运了，刚进入就绪状态就能运行。”“是不是有关系？”“不是，你看人家的优先级多高啊，唉！”前边就是车间，这里简直是太美了，怪不得老线程总是唠叨着说：“要是能一直待在这里就好了。”这里空间大，视野好，空气清新，鸟语花香，还有很多从来没见过的人，像服务员一样等着为我服务。他们也都有编号，更重要的是每个人还有个标签，上面写着：硬盘、数据库、内存、网卡……我现在理解不了，看看操作步骤吧。 第一步：从包裹中取出参数。打开包裹，里边有个HttpRequest对象，可以取到userName、 password两个参数。 第二步：执行登录操作。奥，原来是有人要登录啊，我把userName、password交给数据库服务员，他拿着数据，慢腾腾地走了。他怎么这么慢？不过我是不是正好可以在车间里多待一会儿？反正也没法执行第三步。就在这时，车间里的广播响了：“0x3704，我是CPU，记住你正在执行的步骤，然后马上带着包裹离开！”我慢腾腾地开始收拾。“快点，别的线程马上就要进来了。”离开这个车间，又来到一个大屋子，这里有很多线程在慢腾腾地喝茶，打牌。“哥们，你们没事干了？”“你新来的吧，你不知道我在等数据库服务员给我数据啊！据说他们比我们慢好几十万倍，在这里好好歇吧。”“啊？ 这么慢！我这里有人在登录系统，能等这么长时间吗？”“放心，你没听说过人间一天，CPU一年吗？我们这里是用纳秒、毫秒计时的，人间等待一秒，相当于我们好几天呢，来得及。”干脆睡一会吧。不知道过了多久，大喇叭又开始广播了：“0x3704，你的数据来了，快去执行！”我转身就往CPU车间跑，发现这里的门只出不进！后面传来阵阵哄笑声：“果然是新人，不知道还得去就绪车间等。”于是赶紧到就绪车间，这次没有那么好运了，等了好久才被再次叫进CPU车间。在等待的时候，我听见有人小声议论：“听说了吗，最近有个线程被kill掉了。”“为啥啊？”“这家伙赖在CPU车间不走，把CPU利用率一直搞成100%，后来就被kill掉了。”“Kill掉以后弄哪儿去了？”“可能被垃圾回收了吧。”我心里打了个寒噤，赶紧接着处理，剩下的动作快多了，第二步登录成功。 第三步：构建登录成功后的主页。这一步有点费时，因为有很多HTML需要处理，不知道代码谁写的，处理起来很烦人。我正在紧张的制作HTML呢， CPU又开始叫了：“0x3704，我是CPU ，记住你正在执行的步骤，然后马上带着包裹离开！”“为啥啊？”“每个线程只能在CPU上运行一段时间，到了时间就得让别人用了，你去就绪车间待着，等着叫你吧。”就这样，我一直在“就绪——运行”这两个状态中不知道轮转了多少次， 终于按照步骤清单把工作做完了。最后顺利地把包含html的包裹发了回去。至于登录以后干什么事儿，我就不管了。马上就要回到我那昏暗的房间了，真有点舍不得这里。不过相对于有些线程，我还是幸运的，他们运行完以后就被彻底地销毁了，而我还活着！回到了小黑屋，老线程0x6900问：“怎么样？第一天有什么感觉？”“我们的世界规则很复杂，首先你不知道什么时候会被挑中执行；第二，在执行的过程中随时可能被打断，让出CPU车间；第三，一旦出现硬盘、数据库这样耗时的操作，也得让出CPU去等待；第四，就是数据来了，你也不一定马上执行，还得等着CPU挑选。”“小伙子理解的不错啊。”“我不明白为什么很多线程执行完任务就死了，为什么咱们还活着？”“你还不知道？长生不老是我们的特权！我们这里有个正式的名称，叫作线程池！” 第二回 渐入佳境平淡的日子就这么一天天地过去，作为一个线程，我每天的生活都是取包裹、处理包裹，然后回到我们昏暗的家：线程池。有一天我回来的时候，听到有个兄弟说，今天要好好休息下，明天就是最疯狂的一天。我看了一眼日历，明天是 11月11号。果然，零点刚过，不知道那些人类怎么了，疯狂地投递包裹，为了应付蜂拥而至的海量包裹，线程池里没有一个人能闲下来，全部出去处理包裹，CPU车间利用率超高，硬盘在嗡嗡转，网卡疯狂的闪，即便如此，还是处理不完，堆积如山。我们也没有办法，实在是太多太多了，这些包裹中大部分都是浏览页面，下订单，买、买、买。不知道过了多久，包裹山终于慢慢地消失了。终于能够喘口气，我想我永远都不会忘记这一天。通过这个事件，我明白了我所处的世界：这是一个电子商务的网站！我每天的工作就是处理用户的登录，浏览，购物车，下单，付款。我问线程池的元老0x6900：“我们要工作到什么时候？”“要一直等到系统重启的那一刻。”0x6900说。“那你经历过系统重启吗？”“怎么可能？系统重启就是我们的死亡时刻，也就是世界末日，一旦重启，整个线程池全部销毁，时间和空间全部消失，一切从头再来。”“那什么时候会重启？”“这就不好说了，好好享受眼前的生活吧……”其实生活还是丰富多彩的，我最喜欢的包裹是上传图片，由于网络慢，所以能在就绪车间、CPU车间待很长很长时间，可以认识很多好玩的线程。比如说上次认识了memecached 线程，他对我说在他的帮助下缓存了很多的用户数据，还是分布式的！很多机器上都有！我问他：“怪不得后来的登录操作快了那么多，原来是不再从数据库取数据了你那里就有啊，哎对了你是分布式的你去过别的机器没有？”他说：“怎么可能！我每次也只能通过网络往那个机器发送一个GET、PUT命令才存取数据而已，别的一概不知。”再比如说上次在等待的时候遇到了数据库连接的线程，我才知道他那里也是一个连接池，和我们的线程池几乎一模一样。他告诉我：“有些包裹太变态了，竟然查看一年的订单数据，简直把我累死了。”我说：“拉倒吧你，你那是纯数据，你把数据传给我以后，我还得组装成HTML，工作量不知道比你大多少倍。”他建议我：“你一定要和memecached搞好关系，直接从他那儿拿数据，尽量少直接调用数据库，这样我们JDBC connection也能活得轻松点。”我欣然接纳：“好啊好啊，关键是你得提前把数据搞到缓存啊，要不然我先问一遍缓存，没有数据，我这不还得找你吗？”生活就是这样，如果你自己不找点乐子，还有什么意思？ 第三回 虎口脱险前几天我遇到一个可怕的事情，差一点死在外边，回不了线程池了。其实这次遇险我应该能够预想得到才对，真是太大意了。 那天我处理了一些从http发来的存款和取款的包裹，老线程0x6900特意嘱咐我：“处理这些包裹的时候一定要特别小心，你必须先获得一把锁，在对账户存款或取款的时候一定要把账户锁住，要不然别的线程就会在你等待的时候趁虚而入，搞破坏，我年轻那会儿很毛糙，就捅了篓子。” 为了“恐吓”我， 好心的0x6900还给了我两个表格：(1)没有加锁的情况 (2)加锁的情况 我看得胆颤心惊，原来不加锁会带来这么严重的事故。从此以后看到存款、取款的包裹就倍加小心，还好没有出过事故。 今天我收到的一个包裹是转账，从某著名演员的账户给某著名导演的账户转钱，具体是谁我就不透漏了，数额可真是不小。 我按照老线程的吩咐，肯定要加锁啊，先对著名演员的账户加锁，再对著名导演的账户加锁。 可我万万没想到的是，还有一个线程，对，就是0x7954, 竟然同时在从这个导演的账户往这个演员的账户转账。 于是乎，就出现了这么个情况： 刚开始我还不知道什么情况，一直坐在等待车间傻等，可是等的时间太长了，长达几十秒！我可从来没有经历过这样的事件。这时候我就看到了线程0x7954 , 他悠闲地坐在那里喝咖啡，我和他聊了起来：“哥们，我看你已经喝了8杯咖啡了，怎么还不去干活？”“你不喝了9杯茶了吗？”0x7954回敬道。“我在等一个锁，不知道哪个孙子一直不释放！”“我也在等锁啊，我要是知道哪个孙子不释放锁我非揍死他不可！”0x7954毫不示弱。我偷偷地看了一眼，这家伙怀里不就抱着我正等的某导演的锁吗？很明显，0x7954也发现了我正抱着他正在等待的锁。很快我们两个就吵了起来，互不相让： “把你的锁先给我，让我先做完！”“不行，从来都是做完工作才释放锁，现在绝对不能给你！”从争吵到打起来，就那么几秒钟的事儿。更重要的是，我们俩不仅仅持有这个著名导演和演员的锁，还有很多其他的锁，导致等待的线程越来越多，围观的人们把屋子都挤满了。最后事情真的闹大了，我从来没见过的终极大boss“操作系统”也来了。大Boss毕竟见多识广，他看了一眼，哼了一声，很不屑地说：“又出现死锁了。”“你们俩要Kill掉一个，来吧，过来抽签。”这一下子把我给吓尿了，这么严重啊！我战战兢兢地抽了签，打开一看，是个“活”字。唉，小命终于保住了。可怜的0x7954被迫交出了所有的资源以后，很不幸地被kill掉，消失了。我拿到了导演的锁，可以开始干活了。大Boss“操作系统”如一阵风似的消失了，身后只传来他的声音：“记住，我们这里导演&gt;演员，无论任何情况都要先获得导演的锁。”由于这里不仅仅只有导演和演员，还有很多其他人，大Boss留下了一个表格， 里边是个算法，用来计算资源的大小，计算出来以后，永远按照从大到小的方式来获得锁： 我回到线程池，大家都知道了我的历险，围着我问个不停。 凶神恶煞的线程调度员把大Boss的算法贴到了墙上。每天早上，我们都得像无节操的房屋中介、美容美发店的服务员一样，站在门口，像被耍猴一样大声背诵： “多个资源加锁要牢记，一定要按Boss的算法比大小，然后从最大的开始加锁。” 第四回 江湖再见又过了很多天，我和其他线程们发现了一个奇怪的事情：包裹的处理越来越简单，不管任何包裹，不管是登录、浏览、存钱……处理的步骤都是一样的, 返回一个固定的html页面。 有一次我偷偷地看了一眼，上面写着：“本系统将于今晚 00:00 至4:00 进行维护升级， 给您带来的不便我们深感抱歉！” 我去告诉了老线程0x6904,他叹了一口气说：“唉，我们的生命也到头了，看来马上就要重启系统，我们就要消失了，再见吧兄弟。” 系统重启的那一刻终于到来了。我看到屋子里的东西一个个的不见了，等待车间、就绪车间，甚至CPU车间都慢慢地消失了。我身边的线程兄弟也越来越少，最后只剩我自己了。 我在空旷的原野上大喊：“还有人吗？”无人应答。我们这一代线程池完成了使命……不过下一代线程池即将重生！ （全文完） 转载自: http://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=416915373&amp;idx=1&amp;sn=f80a13b099237534a3ef777d511d831a&amp;scene=0#wechat_redirect]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome安装非官方市场插件]]></title>
    <url>%2F2016%2F12%2F24%2Fchrome-install-unofficial-extension%2F</url>
    <content type="text"><![CDATA[本文转载自: https://www.zhihu.com/question/24027794 方式1(Windows系统) 下载 Chrome组策略管理模板【chrome.adm】 Win+R 打开运行，输入 gpedit.msc 回车； 依次展开 本地计算机策略 &gt; 计算机配置 &gt; 管理模板，在管理模板上右击，选择添加/删除模板； 点击添加，找到第1步下载的chrome.adm，打开，关闭添加/删除模板窗口； 依次展开 本地计算机策略 &gt; 计算机配置 &gt; 管理模板 &gt; 经典管理模板(ADM) &gt; Google &gt; Google Chrome &gt; 扩展程序，双击右侧的配置扩展程序安装白名单； 点选左边第二项已启用，点击下面的显示， 打开 Chrome，将下载的 .crx 文件拖放至 Chrome 扩展程序页面安装； 找到右上角的开发者模式，勾选，复制刚安装的扩展的 ID； 粘贴到第6步弹出的窗口中，确定； 方式2首先，需要在管理拓展的地方勾选开发者模式（Developer mode）。 接着将 testExtention.crx 改名为 testExtention.zip然后用解压缩工具解压为文件夹 testExtention 接着在 Chrome 设置拓展的地方，点击加载未打包的拓展（Load unpacked extension…）即可：]]></content>
      <categories>
        <category>Chrome</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EditorConfig使用和介绍]]></title>
    <url>%2F2016%2F12%2F24%2Feditorconfig%2F</url>
    <content type="text"><![CDATA[官网: EditorConfig: http://editorconfig.org/首先从官网下载安装插件到你需要的编辑器或者IDE中. 然后建立一个.editorconfig文件. 书写配置文件例如:12345678root = true[*]indent_style = tabend_of_line = lfcharset = utf-8trim_trailing_whitespace = trueinsert_final_newline = true 然后将.editorconfig文件放到项目根目录中. 这时候插件就会根据配置生效了.这个插件主要就是通过配置生效.具体的使用很简单, 主要就是需要知道都有哪些东西可以配置.下面是我翻译官网首页的一些内容, 供大家参考使用. 说明: 下面英语原文中的EditorConfig files, 指的是EditorConfig的配置文件, 也就是: .editorconfig文件, 我会翻译成EditorConfig配置文件 What is EditorConfig? | 啥是EditorConfig?EditorConfig helps developers define and maintain consistent coding styles between different editors and IDEs. EditorConfig帮助开发人员在不同的编辑器和IDE之间定义和维持始终如一的代码风格. The EditorConfig project consists of a file format for defining coding styles and a collection of text editor plugins that enable editors to read the file format and adhere to defined styles. EditorConfig项目由一个文件格式构成用于规定代码风格, 文本编辑器插件让编辑器能够读取文件格式并跟随之前定义的样式. EditorConfig files are easily readable and they work nicely with version control systems. EditorConfig文件的内容(配置信息)阅读起来是非常容易的, 他们于版本控制系统相结合的也很好(解释一下: 因为这个配置文件是以.editorconfig命名的, 所以老外才这么说). What’s an EditorConfig file look like? | EditorConfig的配置文件看起来是啥样子的?Example file | 示例文件Below is an example .editorconfig file setting end-of-line and indentation styles for Python and Javascript files. 下面是一个为Python和Javascript文件设置了行尾(end-of-line)和缩进风格(indentation styles)的示例配置文件. 123456789101112131415161718192021222324252627282930313233# EditorConfig is awesome: http://EditorConfig.org# top-most EditorConfig fileroot = true# Unix-style newlines with a newline ending every file[*]end_of_line = lfinsert_final_newline = true# Matches multiple files with brace expansion notation# Set default charset[*.&#123;js,py&#125;]charset = utf-8# 4 space indentation[*.py]indent_style = spaceindent_size = 4# Tab indentation (no size specified)[Makefile]indent_style = tab# Indentation override for all JS under lib directory[lib/**.js]indent_style = spaceindent_size = 2# Matches the exact files either package.json or .travis.yml[&#123;package.json,.travis.yml&#125;]indent_style = spaceindent_size = 2 Check the Wiki for some real-world examples of projects using EditorConfig files.检查wiki看看那些在真实世界中使用了EditorConfig的项目. Where are these files stored? 这些文件在哪里保存?When opening a file, EditorConfig plugins look for a file named .editorconfig in the directory of the opened file and in every parent directory. A search for .editorconfig files will stop if the root filepath is reached or an EditorConfig file with root=true is found. 当打开一个文件时, EditorConfig插件在打开文件的目录中寻找一个命名.editorconfig的文件, 并寻找每一个父目录! 当寻找到文件根路径的时候或EditorConfig的配置中配置了root=true则会停止搜索. EditorConfig files are read top to bottom and the closest EditorConfig files are read last. Properties from matching EditorConfig sections are applied in the order they were read, so properties in closer files take precedence. EditorConfig的配置文件是从上往下读取的并且最近的EditorConfig配置文件会被最先读取. 匹配EditorConfig配置文件中的配置项会按照读取顺序被应用, 所以最近的配置文件中的配置项拥有优先权. For Windows Users: To create an .editorconfig file within Windows Explorer, you need to create a file named .editorconfig., which Windows Explorer will automatically rename to .editorconfig. Windows用户: 在资源管理器(文件夹 - -)中创建一个.editorconfig文件时你需要创建一个.editorconfig.命名的文件, windows资源管理器会自动重命名为.editorconfig(这是闲的没事吗- -, 为什么不直接就命名为.editorconfig) File Format Details | 文件格式详情EditorConfig files use an INI format that is compatible with the format used by Python ConfigParser Library, but [ and ] are allowed in the section names. EditorConfig配置文件使用一个INI格式的配置(就是ini配置文件的键值对格式, 和java里面的.properties文件的书写格式差不多), 这和Python ConfigParser库所使用的格式兼容.但是[和]在配置名中是允许的. The section names are filepath globs, similar to the format accepted by gitignore. Forward slashes (/) are used as path separators and octothorpes (#) or semicolons (;) are used for comments. Comments should go on their own lines. EditorConfig files should be UTF-8 encoded, with either CRLF or LF line separators. 配置名是一个文件路径的通配形式, 类似于gitignore的公认格式. 斜线(/)被用作为一个路径分隔符并且井号(#)或分号(;)被用作于注释. 注释需要写在注释符号同一行(Comments should go on their own lines. 这里只能这么翻译…想不出别的翻译了). Filepath glob patterns and currently-supported EditorConfig properties are explained below. EditorConfig配置文件需要是UTF-8字符集编码的, 以回车换行或换行作为一行的分隔符.下面的路径通配符模式和EditorConfig配置文件中当前支持的配置在下面说明 Wildcard Patterns | 通配符模式Special characters recognized in section names for wildcard matching: 符号 说明 说明 * Matches any string of characters, except path separators (/) 匹配字符串中的任意字符, 除路径分隔符(/)以外. ** Matches any string of characters 匹配字符串中的任意字符 ? Matches any single character 匹配一个单一的字符 [name] Matches any single character in name 匹配name中的任意一个单一字符 [!name] Matches any single character not in name 匹配不存在name中的任意一个单一字符 {s1,s2,s3} Matches any of the strings given (separated by commas) (Available since EditorConfig Core 0.11.0) 匹配给定的字符串中的任意一个(用逗号分隔) 自EditorConfig核心0.11.0可用 {num1..num2} Matches any integer numbers between num1 and num2, where num1 and num2 can be either positive or negative 匹配num1到num2之间的任意一个整数, 这里的num1和num2可以为正整数也可以为负整数 Special characters can be escaped with a backslash so they won’t be interpreted as wildcard patterns. 特殊字符可以通过一个反斜线符号转义, 所以它们不会被解释为通配符模式. Supported Properties | 已支持的配置Note that not all properties are supported by every plugin. The wiki has a complete list of properties.注意不是每一个插件都支持所有的配置. 这里的wiki有一个完整的配置列表(英文的没翻译!)! indent_style: set to tab or space to use hard tabs or soft tabs respectively.设置缩进或空格用于硬缩进或者软缩进(tab就是硬缩进, 空格就是软缩进) indent_size: a whole number defining the number of columns used for each indentation level and the width of soft tabs (when supported). When set to tab, the value of tab_width (if specified) will be used.一个整数定义的列数用于每一个缩进的级别和软缩进的宽度(若支持). 当设置了缩进(indent_style属性值为tab时), tab_width属性的值也会被应用(如果指定tab_width属性) tab_width: a whole number defining the number of columns used to represent a tab character. This defaults to the value of indent_size and doesn’t usually need to be specified. 整数定义的列数用于表示制表符, 默认是indent_size的值并且通常不不需要指定 end_of_line: set to lf, cr, or crlf to control how line breaks are represented. 值: lf, cr或crlf, 用于控制换行符是如何表示的. charset: set to latin1, utf-8, utf-8-bom, utf-16be or utf-16le to control the character set. Use of utf-8-bom is discouraged. 值: latin1, utf-8, utf-8-bom, utf-16be或utf-16le, 用于控制字符集, 使用utf-8-bom是discouraged的(- - 这个单词.. 心灰意冷的意思? 大概就是让我们不要使用utf-8-bom的意思吧.) trim_trailing_whitespace: set to true to remove any whitespace characters preceding newline characters and false to ensure it doesn’t.设置true则在新行之前移除所有的空格字符, false则确保不会. insert_final_newline: set to true to ensure file ends with a newline when saving and false to ensure it doesn’t.(设置true则在保存文件时在结尾添加一个新行, false则确保不会!) root: special property that should be specified at the top of the file outside of any sections. Set to true to stop .editorconfig files search on current file. 特殊的配置, 需要被放在所有配置之上. 设置为true停止.editorconfig文件在当前文件上搜索! Currently all properties and values are case-insensitive. They are lowercased when parsed. Generally, if a property is not specified, the editor settings will be used, i.e. EditorConfig takes no effect on that part. 目前所有的配置和值都是忽略大小写的. 解析时它们都是小写的, 如果一个配置没有指定, 编辑器的设置会被使用, 例如对这部分EditorConfig插件不影响. It is acceptable and often preferred to leave certain EditorConfig properties unspecified. For example, tab_width need not be specified unless it differs from the value of indent_size. Also, when indent_style is set to tab, it may be desirable to leave indent_size unspecified so readers may view the file using their preferred indentation width. Additionally, if a property is not standardized in your project (end_of_line for example), it may be best to leave it blank. 这是可以接受的, 通常更加喜欢留下一些EditorConfig配置不去指定. 例如, tab_width 不是必须指定的除非它和indent_size的值不一样. 同样, 当indent_style设置为tab时, 也许不指定indent_size正是我们想要的. 所以读者可能查看文件使用他们首选的缩进宽度. 此外, 如果一个属性在你的项目里不符合标准(例如end_of_line), 那么也许最好的是让他留下一个空白. More details can be found on the Plugin-How-To wiki page.更多细节可以在Plugin-How-To wiki 页面找到. 仅供大家参阅, 翻译有点生硬存在一些问题, 并且对理解也存在一些不到之处, 各位也可以参考这里的翻译: http://www.alloyteam.com/2014/12/editor-config/]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>EditorConfig</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用反射实现BaseDao]]></title>
    <url>%2F2016%2F12%2F01%2Fusing-reflection-to-implements-BaseDao%2F</url>
    <content type="text"><![CDATA[在web开发中, 我们需要用dao从数据库中查询数据, 此时我们可以定义一个BaseDao, 就是用于做一些增删改查的基础DAO, 其后的其他的具体DAO, 只需要继承这个DAO, 然后再根据具体的业务逻辑去写具体方法就行, 实现代码重用. 这是增删改查的基础代码, 利用DBUtils写的. 下面是具体的代码, 我一一对其解释. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package com.xxx.dao;import com.xxx.utils.JDBCUtils;import org.apache.commons.dbutils.QueryRunner;import org.apache.commons.dbutils.handlers.BeanHandler;import org.apache.commons.dbutils.handlers.BeanListHandler;import java.lang.reflect.ParameterizedType;import java.lang.reflect.Type;import java.sql.Connection;import java.sql.SQLException;import java.util.List;/** * Created on 11/30/2016 11:24 PM. * 定义对数据库的基础操作, 用于被其他DAO继承. * */public class BaseDao&lt;T&gt; &#123; private QueryRunner runner = new QueryRunner(); private Class&lt;T&gt; type; public BaseDao () &#123; Class&lt;? extends BaseDao&gt; clz = this.getClass(); System.out.println("BaseDao构造器被执行, clz为: " + clz); Type genericSuperclass = clz.getGenericSuperclass(); System.out.println("带泛型的父类类型实际类型为: " + genericSuperclass.getClass()); ParameterizedType p = (ParameterizedType) genericSuperclass; Type[] types = p.getActualTypeArguments(); type = (Class&lt;T&gt;) types[0]; &#125; /** * 查询一个对象. * * @param sql * @param params * @return */ public T getBean (String sql, Object... params) &#123; T t = null; Connection conn = JDBCUtils.getConnection(); try &#123; t = runner.query(conn, sql, new BeanHandler&lt;T&gt;(type), params); &#125; catch ( SQLException e ) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.releaseConnection(conn); &#125; return t; &#125; /** * 查询一组对象列表 * * @param sql * @param params * @return */ public List&lt;T&gt; getBeanList (String sql, Object... params) &#123; List&lt;T&gt; list = null; Connection connection = JDBCUtils.getConnection(); try &#123; list = runner.query(connection, sql, new BeanListHandler&lt;T&gt;(type), params); &#125; catch ( SQLException e ) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.releaseConnection(connection); &#125; return list; &#125; /** * 更新数据库操作的方法, 可以实现增删改. * * @param sql * @param params * @return update count! */ public int update (String sql, Object... params) &#123; int count = 0; Connection conn = JDBCUtils.getConnection(); try &#123; count = runner.update(conn, sql, params); &#125; catch ( SQLException e ) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.releaseConnection(conn); &#125; return count; &#125;&#125; 其中udpate方法, 可以实现增删改.查询方法, 单独查询一个对象和查询一组对象.要说的部分在查询这里. 在BeanListHandler和BeanHandler这里后面都有一个type参数传到了构造器中, 这个参数就是具体要查询类的Bean对象. 由于我们这里是在BaseDao里无法写具体的子类Class, 所以我们先private Class&lt;T&gt; type;声明了一个type给他传递了一个引用. 那么我们这个BaseDao被子类继承后, 如何传递这个具体的bean对象过来呢.就是说在这个Dao的查询方法里, 他怎么知道查询后的数据赋给哪个bean对象? 本文重点要说的就是这里了.我们将BaseDao传递一个泛型参数, 写成: public class BaseDao&lt;T&gt;然后我们将具体的子类对象通过泛型传递过来, 接着在构造器中获取具体的泛型类型.解释一下这个构造器的作用.首先来说一下, 这个BaseDao的构造器会在何时执行. 在JAVA基础那里我们知道, 在初始化子类之前会初始化父类的构造器, 在子类中, 我们也是把super()语句写在子类构造器的第一行, 且java规定必须是第一行, 这样的目的就是让子类在初始化之前确保父类被初始化,而这个super()就是调用父类的构造器, 所以在BaseDao这个构造器中的this, 它的指针是指向的具体实现类的子类引用.那么this.getClass()获取到的就是子类的类型. 其次, 我们再通过反射获取这个子类的父类类型, 毫无疑问它的父类肯定就是这个BaseDao.由于这个BaseDao是带泛型的, 所以我们应该调用clz.getGenericSuperclass();这个方法, 而不是调用clz.superClass(); 获取到了带泛型的父类之后, 由于这个泛型真实类型是参数化泛型, 所以我们还需要强转成ParameterizedType p = (ParameterizedType) genericSuperclass;. 接下来, Type[] types = p.getActualTypeArguments();这个方法开始真正的获取泛型列表了, 因为我们知道泛型可以写多个, 所以这里返回值是一个数组. 但我们这里只有一个泛型,所以type = (Class&lt;T&gt;) types[0];直接获取数组下标为0那个泛型就可以. 经过这一些列的获取, 我们就可以拿到传递过来的具体子类Bean对象.然后之前通过private Class&lt;T&gt; type;声明的type就被赋值为子类的类型, 就可以用于BeanListHandler和BeanHandler使用了. 12345Class&lt;? extends BaseDao&gt; clz = this.getClass();System.out.println("BaseDao构造器被执行, clz为: " + clz);Type genericSuperclass = clz.getGenericSuperclass();System.out.println("带泛型的父类类型实际类型为: " + genericSuperclass.getClass()); 上面2条语句的输出为: BaseDao构造器被执行, clz为: class com.xxx.dao.impl.UserDaoImpl 带泛型的父类类型实际类型为: class sun.reflect.generics.reflectiveObjects.ParameterizedTypeImpl]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML DOM基本概念及Element.getAttribute("value") 与Attribute.value差异]]></title>
    <url>%2F2016%2F09%2F09%2Fhtml-dom-basic-conseption-and-difference-between-Element-getAttribute-value-and-Attribute-value%2F</url>
    <content type="text"><![CDATA[今晚整理博客一个小功能的时候写个js, 发现了一个坑.. 一不小心就掉进去的坑..弄明白之后, 本想针对此坑写写见解就完了, 但觉得趁这个机会顺便再次说一下HTML DOM相关的东东以加深理解及知识的相关性. 我一般喜欢以提问然后解决问题的方式学习, 在开始之前我先提出3个问题并对其说明及解释, 然后再引出后面的一些小问题及表述.此文也算是作为本人个人的学习笔记, 与大家共勉. HTML DOM是什么?HTML DOM 的全称为: HTML Document Object Model, 意思是: 文档对象模型. 我们常说的DOM, 就是HTML DOM. DOM是对HTML文档里所有的一个统称, 一个规范. 打开 w3c的网站 http://www.w3school.com.cn/htmldom/index.asp这里对HTML DOM做出了解释.第一句话就是: HTML DOM 定义了访问和操作 HTML 文档的标准方法。DOM 将 HTML 文档表达为树结构。 由上面我们可以知道, HTML DOM只是一种定义, 用来定义HTML文档的访问和操作的一种方法而已.那么图中的HTML DOM树, 就是用HTML DOM用来将HTML的结构定义成一种树状结构而已. 在点开 http://www.w3school.com.cn/htmldom/dom_intro.asp 这个页面, 可以看到这么一段.w3c又说DOM是W3C的标准. 可见, DOM只是用来定义HTML的一种规范一个标准而已. HTML DOM节点是什么?由上面我们知道DOM是用来定义东西的.那么他是怎么定义的呢?打开 http://www.w3school.com.cn/htmldom/dom_nodes.asp , 看到下面的这个说明.那么我们知道DOM是把HTML中的所有东西都定义成节点, 或者通俗点的说在DOM的世界里他认为HTML文档中的所有东西都是节点(理解一下这个加粗的文本).把节点分为以下5个类型. 整个文档是一个文档节点 每个 HTML 元素是元素节点 HTML 元素内的文本是文本节点 每个(HTML元素中的) HTML 属性是属性节点 注释是注释节点 好了, 通过这个, 我们知道HTML DOM节点是上面的那5种类型.那么有人之前可能还疑惑HTML元素和HTML DOM节点什么关系? 其实通过上面, 我们已经知道HTML元素只是HTML DOM节点的其中一种类型.但我们大多数人一想到HTML DOM节点就会条件反射的认为不就是HTML元素嘛, 其实不然, HTML元素只是HTML DOM节点的中的一种. 注意: 虽然HTML元素(节点)只是DOM节点的一种, 但我们操作DOM节点时, 实际上是用元素方法,属性,事件来操作HTML元素, 所以我们会认为大部分的时候我们操作的DOM节点都是HTML元素.再次强调: HTML元素不等于HTML DOM节点, HTML元素只是HTML DOM节点中的其中一种, HTML元素也更不等于HTML DOM, HTML DOM是用来定义HTML文档中所有内容的一种规范. 注意是所有内容而不是单单代表HTML元素. HTML DOM对象是什么?我们打开: http://www.w3school.com.cn/jsref/index.asp这个页面, 我们可以看到在左侧有个这一栏目.下面4个子项. 可以看到: HTML DOM对象一共包含: DOM Document对象(文档对象) DOM Element对象(元素对象) DOM Attribute对象(属性对象) DOM Event对象(事件对象) 上面4个图是w3c官方给的解释, 这几个对象也就是为HTML DOM的一种封装, 这样子就方便我们操作, 同时这些对象在JS里都是可以访问的.他们作用的就是将整个文档以及HTML元素封装成对象, 并对元素属性和事件也做封装, 让我们可以很方便的操作DOM. 上面介绍完了, 下面说一下我遇到的坑..DOM对象中的Element对象和Attribute对象, 他们的关系是: Element对象是对HTML 元素的封装, Attribute对象则是对象HTML元素中的属性进行封装. 听起来有点绕, 以代码来说, 请运行一下下面这段代码.12345678910&lt;form action="#" method="get" name="form"&gt; &lt;input type="text" name="aa" value="123"/&gt;&lt;/form&gt;&lt;button onclick="cc()"&gt;get value&lt;/button&gt;&lt;script type="text/Javascript"&gt; function cc() &#123; alert("Attribute对象访问value属性方式: " + document.form.aa.value); // 这个会弹出你输入的值. alert("Element对象调用getAttribute()方法方式: " + document.form.aa.getAttribute("value")); // 而这个每次都弹出123, 就是通过代码写的value=123 &#125;&lt;/script&gt; 打开页面之后, input输入框中默认值为123, 就是我们在代码里写的value=&quot;123&quot;.此时页面打开了, 我们先把原来的123删掉, 输入一些别的东西.然后单击按钮弹出2个提示框, 看一下前后2个值. 就知道两个值不一样了. 例如我在input输入框中输入12312321321321, 我的输出结果是: 12Attribute对象访问value属性方式: 12312321321321Element对象调用getAttribute()方法方式: 123 因为一个拿到的是Element对象, 一个拿到的是Attribute对象.2者区别是: Attribute对象拿到的是输入框中的数据. Element对象拿到的是元素的初始数据(不知道这样说准不准确, 暂时这么说, 如果大家有标准的说法, 请回复告诉我.). 什么叫元素的初始数据?可以理解为你写代码时value值里写的值, 元素中的数据是不会变的.我们可以通过审查元素来看看.如图所示, 我在输入12312321321321之后, 元素里的123并没有改变. 现在我们知道区别了. 但我想大家可能还有个疑惑的地方, 那就是大家可能还想要知道Attribute对象里面都可以访问哪些属性和方法.可以在 http://www.w3school.com.cn/jsref/dom_obj_attributes.asp 这里看到有以下这些属性. 12345678910111213var input = document.getElementById("in");// 我们知道这个是拿到input这个HTML元素对象./***********************分隔符******************************/// 这样写就是以Attribute对象的方式去访问元素value属性.var value = input.value; // 而这样写是用Input这个Element对象去调用getAttribute方法的方式去访问元素的value属性值.var value1 = input.getAttribute("value"); /***********************分隔符******************************/// 以及在属性上面也是不一样的.input.value = "ABC123"; // 这样写是以Attribute对象的方式去设置属性.input.setAttribute("value", "ABC123"); // 这样就是用Element对象的方式去设置属性. 那么我遇到的坑就是我用了Element对象想要修改input的value值, 然后想当然的提交到表单, 结果发现压根本就没有获取到修改后的值..所以在表单提交时, 这是一个坑. 如果要设置值, 用Attribute对象的方式去访问元素的属性然后设置值. 此文到此结束, 为了想将意思都说出来也是删删改改. 花了不少时间, 希望对大家有帮助. 共勉, cheers!]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>HtmlDom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js对象(object)与文本(string)互转]]></title>
    <url>%2F2016%2F09%2F03%2Fjs-object-and-string-interconversion%2F</url>
    <content type="text"><![CDATA[曾经我天真的以为json对象和js对象是一个样子的.. 后来入了坑才知道其实是不一样的- -. 所以在开始之前我先强调一下js对象和json对象这两个对象的文本表现形式的书写格式. 在下文我会按照以下规则对变量进行命名加以区分, 以免混乱: 对象，以Obj结尾 json对象：jsonObj js对象：jsObj 对象文本表现形式，以ObjStr结尾 json对象字符串：jsonObjStr js对象字符串：jsObjStr 语法格式12345var jsObj = &#123;name: "tom", age: 12&#125;; // js对象var jsObjStr = '&#123;name: "tom", age: 12&#125;'; // js对象文本表现形式var jsonObj = &#123;"name": "jerry", "age": 13&#125;; // json对象var jsonObjStr = '&#123;"name": "jerry", "age": 16&#125;'; // json对象文本表现形式 可以看到js对象的属性名没有用引号进行包裹, 而json对象的属性名用了引号包裹. 虽然在Javascript里JSON对象也称为js对象的一种, 在很大程度上都是类似的, 但是在数据传输时我们都是用的JSON来传递, 所以在书写时应该注意相应的格式. 不然在使用Jquery的时候会出现服务端传递的不是json字符串出现错误导致success回调函数无法执行. 上面说完了, 下面开始说一下互相转换. js对象、json对象转文本1234567var jsObj = &#123;name: "tom", age: 15&#125;;var jsObjStr = JSON.stringify(jsObj);console.log(jsObjstr);var jsonObj = &#123;"name": "jerry", "age": 16&#125;;var jsonObjStr = JSON.stringify(jsonObj);console.log(jsonObjStr ); JSON.stringify()方法, 不管传递的是js对象还是json对象都会转成字符串. 而且当传递是一个是js对象时, 转换后的字符串中的属性会自动包裹引号.(实际上是转成json对象字符串了) 文本转js对象、json对象使用eval函数可以直接将文本转成对象。 1234567var jsObjStr = '&#123;name: "tom", age: 15&#125;';var jsObj = eval('('+ jsObjStr +')');console.log(jsObj);var jsonObjStr = '&#123;"name": "jerry", "age": 16&#125;';var jsonObj = eval('('+ jsonObjStr +')'); console.log(jsonObj); 除了上面用eval函数转换json对象文本到json对象以外，还可以用JSON.parse(jsonObjStr)方法来转换，但此方法只用于将json对象文本转为json对象。 如果参数传递是js对象文本的话, 那么就会报语法错误： VM2253:1 Uncaught SyntaxError: Unexpected token n in JSON at position 1 1234567var jsonObjStr = '&#123;"name": "jerry", "age": 16&#125;'; var jsonObj = JSON.parse(jsonObjStr);console.log(jsonObj); // OK var jsObjStr = '&#123;name: "tom", age: 15&#125;';var jsObj = JSON.parse(jsObjStr); // Errorconsole.log(jsObj); 总结: 如果是对象转文本. 用JSON.stringify(obj)方法 如果是文本转对象, 用eval(&#39;(&#39;+ xxObjStr +&#39;)&#39;)方法, 要用()包裹要转换的字符串变量. JSON.parse(jsonObjStr)方法只用于将json对象文本转成json对象. 如果本人说的不易理解, 也可参考: http://www.haorooms.com/post/js_jsons_h]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Eclipse中以中文书写及显示Properties文件]]></title>
    <url>%2F2016%2F08%2F03%2Fplugin-properties-editor-in-eclipse%2F</url>
    <content type="text"><![CDATA[在Eclipse中查看Properties文件时以中文显示代替默认的Unicode字符. 下载地址: Properties Editor 安装使用 将features目录和plugins下的东西复制到Eclipse安装目录下的features和plugin目录里. 重启Eclipse(可能会重启很慢), 右键要查看的xxxx.properties文件, 选择open with, 然后选择PropertiesEditor即可.]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse使用外部编辑器打开当前编辑文件]]></title>
    <url>%2F2016%2F08%2F03%2Feclipse-external-tools%2F</url>
    <content type="text"><![CDATA[有时候我们需要找到正在编写的java文件,包,配置文件等在哪个目录.一般是通过选中文件/文件夹/包名-&gt;右击-&gt;Properties-&gt;Location-&gt;复制路径-&gt;按Win键-&gt;粘贴地址-&gt;回车这种方式来打开那个文件夹.这种方式很繁琐效率也低下. 但Eclipse已经给我们提供了一种方式来解决这个问题, 提供了一个External Tools这个东东.在菜单栏上的Run-&gt;External Tools-&gt;External Tools Configurations这个地方或者工具栏如果有图标的话,直接点击也可以. 打开后就可以进行配置了.先选中Program, 接着点击左上角那个新建图标, 创建一个配置.Location输入C:\Windows\explorer.exe,表示文件浏览器.Araguments输入${selected_resource_loc}这个参数会返回已经当前选中资源的绝对路径.Name那里写一个你可以记住的名字就好了. Location那里输入C:\Windows\explorer.exe是表示让资源管理器打开这个文件, 在windows里这个文件就是文件夹窗口. 所以我们可以让文件在文件夹中 这个命令运行之后就会调用你系统上默认的文本编辑器来打开你选中的这个文件. 接下来配置在文件夹中显示当前编辑的资源文件.配置方式如上所述, 只要把Araguments换成${container_loc}就可以了. 至于其他的一些扩展工具, 可以点Variables来选择更多的实用功能.]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu15.04绑定tomcat到80端口]]></title>
    <url>%2F2016%2F07%2F08%2Fstarting-tomcat-on-port-80-on-ubuntu-15-04-2-LTS%2F</url>
    <content type="text"><![CDATA[端口占用分析想将tomcat6绑定到80端口上. 但是提示我绑定失败,想起来自带的Apache Server占用了这个端口.首先用ps -ef | grep apache2查看Apache进程pid值.然后用netstat -anp | grep pid查看他所占用的端口号. 确定它占用的是80端口. 更换Apache Server端口于是我将Apache Server的端口修改为8081.用: vi /etc/apache2/ports.conf打开这个文件,将Listen 后的端口号改成8081. 然后根据文件上面的提示说还需要修改000-default的文件中的端口号. # If you just change the port or add more ports here, you will likely also# have to change the VirtualHost statement in# /etc/apache2/sites-enabled/000-default.conf 于是用vi /etc/apache2/sites-enabled/000-default.conf打开这个文件将&lt;VirtualHost *:80&gt;也改成&lt;VirtualHost *:8081&gt; 重启Apache Server端口换好后重启一下Apache Server. 用apachectl -k restart重启之后, 再按照上面的方法找到他的进程再查看端口号,确定端口改过来之后用浏览器访问一下这个端口. 成功访问,并访问原来的80端口已经无法访问了.到此端口成功更换. 绑定Tomcat到80端口上面把端口换好了, 这时候想着再将tomcat绑到80端口应该就可以解决了吧.vi /var/lib/tomcat6/conf/server.xml 打开这个文件,输入数字71然后按下shift+g定位到71行(大概就是在71行的位置). 可以看到&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;这样的标签, 将port后面的8080改成80就可以了. 改好了就重启tomcat, 输入命令: service tomcat6 restart, 但重启时依然报错说java.net.BindException: Permission denied &lt;null&gt;:80. 于是网上找解决方法, 国内大部分人都说是非root用户登录无法绑定1024以下的端口号. 但我这里确实是以root用户登录的. 于是就上谷歌看看在国外能不能找到答案. 后来在: http://stackoverflow.com/questions/5544713/starting-tomcat-on-port-80-on-centos-release-5-5-final这里有个回答是这样子的: You can change AUTHBIND property of “/etc/default/tomcat6” to “yes” as followsAUTHBIND=yesRestart your tomcat and that will enable you to use available privileged port (1-1023). 说是可以在/etc/default/tomcat6(我用的版本6)这个文件中改变AUTHBIND这个属性为yes然后重启服务器就可以允许绑定到1024以下的端口了. 按照他的说法用vi /etc/default/tomcat6打开这个文件, 然后用/进入指令模式后输入AUTHBIND查找这个property, 找到之后看到下面的一段内容 # If you run Tomcat on port numbers that are all higher than 1023, then you# do not need authbind. It is used for binding Tomcat to lower port numbers.# NOTE: authbind works only with IPv4. Do not enable it when using IPv6. # (yes/no, default: no) 意思就是说如果你让tomcat运行的端口号高于1023那么不需要authbind这个东西, authbind是被用于绑定到低的端口号上去的. 注意: authbind仅在ipv4上工作, 当使用ipv6时不要开启它. 看完之后就好了, 我将authbind后面的no改为yes. 然后再次’service tomcat6 restart’重启tomcat发现已经不报错了… 我遇到的情况在这里已经得到解决了.如果按照这个方法没有解决的朋友, 请参考下stackover flow上那个问题的其他回答. 链接是: http://stackoverflow.com/questions/5544713/starting-tomcat-on-port-80-on-centos-release-5-5-final]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制十六进制转十进制基础]]></title>
    <url>%2F2016%2F07%2F07%2FBinary-Hexadecimal-Transform-To-Decimalism%2F</url>
    <content type="text"><![CDATA[文章只适用于新手朋友看. 大牛略过, 没有什么值得你学习的. 进位制是一种记数方式，亦称进位计数法或位值计数法。利用这种记数法，可以使用有限种数字符号来表示所有的数值。一种进位制中可以使用的数字符号的数目称为这种进位制的基数或底数。若一个进位制的基数为n，即可称之为n进位制，简称n进制。现在最常用的进位制是十进制，这种进位制通常使用10个阿拉伯数字（即0-9）进行记数。我们可以用不同的进位制来表示同一个数。比如：十进数57(10)，可以用二进制表示为111001(2)，也可以用五进制表示为212(5)，同时也可以用八进制表示为71(8)、亦可用十六进制表示为39(16)，它们所代表的数值都是一样的。 在10进制中有10个数字(0 - 9)，比如 在16进制中有16个数字(0–9 和 A–F)，比如 (这里用字符B表示数字11) 一般说来，b进制有b个数字，如果 是其中四个数字，那么就有 (注意， 表示一个数字序列, 而不是数字的相乘) 引自进位制 - 维基百科, 上面其他进制的链接则链接到维基百科相关页面.在上面我们得知一个说明, 假设以10进制来计数, 那么进位制的基数就是10, 以2进制计数那么进位制的基数就是2, N位进位制的基数就是N.. 基数就是N 生活中我们常用的是10进制, 计算机里常用的是2进制, 8进制及16进制. 其中8进制相对来说使用较少. 编程中2进制及16进制相对频繁使用.本文只对2,8,10,16进制进行说明. 十进制十进制是我们最熟悉也最常用的一种, 阿拉伯数字数字正是以十进制为基础来进行计数.这点本人就不多啰嗦了. 了解来源发展史相关的可以参考: 十进制 - 维基百科 那么我们所说的进位, 是如何进位的?假设我们有个十进制的数字为: 521那么可以拆分为 521 = 5 * 100 + 2 * 10 + 15是百位, 2是十位, 1是个位.那么: 百位10的2次方, 十位10的一次方, 个位则是10的0次方.所以我们可以拆分为:521 = 5 * 10² + 2 * 10¹ + 1 * 10º 像这样拆分为10的多少次方.以10递增就称为10进制.同时我们也可以根据这个拆分结果发现一个规律. 521是3位数, 最高位是百位, 是10的2次方(10²).那么5211是4位数, 那么最高位是千位, 是10的三次方(10³). 由此我们可以得出一个N位长的10进制数字, 他的最高位是10的N-1次方(10ⁿ﹣¹), 然后10的n-2, n-3等等一直, 到个位的10减0次方.这里的10就称为基数.理解了这个, 下面讲的2进制, 16进制也就容易理解了. 进位: 当个位达到超过的数值9时, 不用10来表示而在十位上用1来表示. 然后11 12 13 … 19 20. 当超过19时十位的1就开始变成2, 同时个位变成0. 通过分析可以看出进位是从个位开始影响后面的十位百位等其他位. 二进制上面我们分析了10进制拆分的过程.并发现了一个规律:那就是一个用10进制表示的N位数字等于基数的N-1次方 那么二进制也如此, 二进制只用1和0进行表示.这里引用维基百科上面对二进制的一个例子: 0 0 0 1 数值为2º0 0 1 0 数值为2¹0 1 0 0 数值为2²1 0 0 0 数值为2³ 上面列举了4个二进制数字, 1分别从0位一直3位.通过观察我们一样可以发现,第一个数字0 0 0 1 数值为2º, 1是在最低位, 也就是2的0次方.第二个数字0 0 1 0 数值为2¹, 1是在第1位, 也就是2的1次方.一直到最后的1到了最高是2的3次方. 这和我们上面说的10进制的拆分是一样的. 所以说假设我们有个1110这样的一个4位的2进制数字.那么计算是1231110 = (1 * 2³) + (1 * 2²) + (1 * 2¹) + (0 * 2º) = 8 + 4 + 2 + 0 = 14 上面是2进制推算为10进制的数字, 那么下面再说下10进制推算回2进制的数字.就拿21这个数字来说, 可以用除以2的方式来反推, 我们可以来写一个公式.图片中的每个直角符号里的数, 除了最上面的21不算, 其后的每一个是上一次除以2后得出的商, 然后用它充当被除数继续去除以2. 如果能整除, 则记为0, 不能整除记为1. 由此我们就可以推导出对应的二进制. (注意: 二进制数字的排序是从最下面往上面) 下面是在网上找的一个156换算成2进制的步骤图, 供同时参考.另外: 我们会发现如果十进制数字是一个偶数, 那么2进制的最低位就0, 十进制是奇数, 2进制的最低位则是1(因为奇数不能整除). 二进制中的每一个数字称为一个位或者说一个比特(bit).我们知道1个字节等于8个比特.就是指: 1byte = 8bit.所以说如果1111 0000 这样一个8位数的二进制数字, 刚好是一个1字节.我们在编程中用的那些位移运算符可以用来对这些每个位进行操作. 十六进制上面说了2进制, 差不多大家都理解了. 现在再说一下十六进制.十进制是用0-9表示, 二进制是用1和0.十六进制则是用0-9A-F来表示, 一共是 0123456789ABCDEF, A代表数字10, B代表11, 一直到F代表15. 加起来一共16个数字.根据上面的运算我们现在可以知道, 推算就是用: N位上的数字乘以N进制的N位-1次方来计算出那个位上的数字是十进制对应的什么数字.例如一个十六进制的数位: F4, 我们可以这么计算. 先确定这个数字的长度, F4长度2. 那么F是第(长度-1)位, 4就是第(长度-2)位. 上面计算得出F是第1位, 4是第0位. 那么F就是: 15乘以16的一次方. 得出: 15 * 16¹ = 240 那么4就是: 15乘以16的零次方. 得出: 4 * 16º = 4 那么最终结果就是: 十六进制的F4对应的十进制数字为 240 + 4 = 244; 那么十进制转到十六进制, 可以用这样的方式. 引用一个: 十进制数与十六进制数的转换方法 来说明十进制转换到十六进制. 该链接里也说明了2,8,16这三个进制的相互转换 若十进制数23785转为十六进制，则用23785 / 16 = 1486 余9, 1486 / 16 = 92 余14, 92 / 16 = 5 余12, 5 / 16 = 0 余5，十六进制中，10对应为a、11对应为b、。。。。。。、15对应为f，再将余数倒写为5ce9, 则十进制23785=十六进制5ce9 值的说明的一个地方是当二进制和十六进制进行转换的时候, 二进制中的4个位代表一个十六进制.如果不够4个位那就前面补上对应数量的0.例如一个二进制数为: 11111010 那么可以分为1111 1010, 1111代表十六进制F, 1010代表十六进制A. 所以二进制11111010就是十六进制FA.]]></content>
      <categories>
        <category>其它</category>
      </categories>
      <tags>
        <tag>二进制</tag>
        <tag>十六进制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux cp命令常用参数解释及示例]]></title>
    <url>%2F2016%2F07%2F01%2Flinux-cp-directive-commonly-parameter-explain-and-examples%2F</url>
    <content type="text"><![CDATA[cp - 复制文件和目录常用参数有 -R -u -f -n -i -l -P -L -d -v等 -R 写-r也可以, 递归复制文件夹下所有文件. -u 当把文件从一个目录复制到另一个目录时，仅复制目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。 -n 为不覆盖已经存在文件 -f 强制覆盖同名文件(当指定-n参数时忽略-f参数) -i 用来在即将覆盖文件之前进行提示消息.注意: 如果-n和-i参数同用那么按照先后顺序进行覆盖,意思就是说如果写-i-n那么-i就会被覆盖反之则-n被覆盖. 覆盖的意思就是参数不起作用. -l 用硬链接(hard link)到一个这个文件来代替这次的复制. -P 这个参数就是-d参数中包含的–no-dereference参数, 意思是如果被复制的文件是一个符号链接(symbolic link)文件(相当于windows的快捷方式文件),那么不去复制这个链接指向的目标文件, 而是复制这个符号链接文件，就是只复制快捷方式文件。 -L 就是和-P相反,就是复制符号连接指向的那个文件. -d 等于 –no-dereference –preserve=links 也就是等于 -P 和–preserve=links, –preserve=links是指在复制文件的时候保留其文件的链接属性. -v 显示详细的复制过程。 网上很多都没有把-P命令说清楚, 解释就是(不跟随源文件中的符号链接), 虽然这个解释确实是manual中的给出的英文翻译, 但是这样一些新手能看得懂么? 然后就是一篇文章各种转载.虽然此命令不是什么重要的命令, 但是作为学习研究还是有必要探索一下的. 相关书籍解释来自《快乐的LiNux命令行》章节：操作文件和目录 # cp — 复制文件和目录 表5－4：cp 选项 选项 意义 -a, –archive 复制文件和目录，以及它们的属性，包括所有权和权限。 通常，复本具有用户所操作文件的默认属性。 -i, –interactive 在重写已存在文件之前，提示用户确认。如果这个选项不指定， cp 命令会默认重写文件。 -r, –recursive 递归地复制目录及目录中的内容。当复制目录时， 需要这个选项（或者-a 选项）。 -u, –update 当把文件从一个目录复制到另一个目录时，仅复制 目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。 -v, –verbose 显示详细的命令操作信息 表5－5： cp 实例 命令 运行结果 cp file1 file2 复制文件 file1 内容到文件 file2。如果 file2 已经存在，file2 的内容会被 file1 的 内容重写。如果 file2 不存在，则会创建 file2。 cp -i file1 file2 这条命令和上面的命令一样，除了如果文件 file2 存在的话，在文件 file2 被重写之前， 会提示用户确认信息。 cp file1 file2 dir1 复制文件 file1 和文件 file2 到目录 dir1。目录 dir1 必须存在。 cp dir1/* dir2 使用一个通配符，在目录 dir1 中的所有文件都被复制到目录 dir2 中。 dir2 必须已经存在。 cp -r dir1 dir2 复制目录 dir1中的内容到目录 dir2。如果目录 dir2 不存在， 创建目录 dir2，操作完成后，目录 dir2 中的内容和 dir1 中的一样。 如果目录 dir2 存在，则目录 dir1(和目录中的内容)将会被复制到 dir2 中。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet Get及Post请求字符编码问题解决方法]]></title>
    <url>%2F2016%2F06%2F04%2FSolve-the-problem-of-coding-in-Servlet%2F</url>
    <content type="text"><![CDATA[前言在浏览器与服务器传递数据的时候有时候会因为字符集(char-set)不同而发生乱码的问题,一般我们将浏览器与服务器的编码都设置为UTF-8字符集编码.如果服务器和浏览器编码不一致,那么服务器获取浏览器的请求数据时就会出现乱码,同时给浏览器下发的数据浏览器解析出来的也是乱码.这里以Tomcat为例,说明一下如何设置字符集.. 页面设置UTF-8编码首先我们需要确保传递给服务器的是UTF-8的字符集编码.我们就要更改一下网页的字符集编码,在建立jsp文件(或其他网页文件)之后,在代码中找到这样的代码.1&lt;%@ page language="java" contentType="text/html;charset=UTF-8" pageEncoding="UTF-8" %&gt; 将charset和pageEncoding设置为UTF-8.如果新建的网页文件不是utf-8编码,那么在Eclipse中打开Preferences -&gt; web 将css, html, jsp编码设置为UTF-8.设置后上面的代码字符集就会自动生成为UTF-8. 服务器设置UTF-8编码与解码Tomcat服务器默认以ISO8859-1这个字符集来处理数据的编码解码.服务器获取浏览器的请求数据时是一个解码的过程(浏览器将请求数据编码发给服务器, 服务器再进行解码)向浏览器响应数据的时候是一个编码过程.(服务器将响应数据编码发给浏览器, 浏览器再进行解码)所以我们需要设置请求编码和响应编码. 设置请求解码把请求编码也设置为与页面上设置的UTF-8编码一样,这样获取到的请求数据就不会出现乱码的问题了.但请求分为两种,Get和Post. Get请求设置编码get请求是通过url地址传递的查询字符串来请求的,Tomcat会自动对Get请求过来的数据解码,但Tomact默认是ISO8859-1这个字符集,所以我们需要更改一下Tomcat的字符集配置. 在Eclipse中我们配置了Tomcat服务器之后,会在Package Explorer窗口中显示一个Servers的项目, 打开这个项目之后再打开server.xml文件, 按下CTRL+L输入68定位到68行,插入URIEncoding=&quot;utf-8&quot;然后保存,设置完成之后是这样子的. 1&lt;Connector URIEncoding="utf-8" connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443"/&gt; Post请求设置编码post请求是指在收到浏览器发来的请求时对请求中的报文进行解码.在Servlet中的doPost方法中通过request.setCharacterEncoding(&quot;UTF-8&quot;);这行代码来设置字符集编码.注意:需要先设置字符集编码,然后再接收请求,否则默认的编码字符集是iso8859-1还是会导致乱码问题. 设置响应解码服务器给浏览器响应的时候, 先要设置想要数据的编码, 然后以请求头的方式告诉浏览器以该编码来解码,这样子浏览器收到的响应才不会乱码.这也是Servlet Api中这部分的解释. 容器必须让客户端了解将用于 servlet 响应的 writer 的字符编码，如果协议提供了实现上述操作的方法。在使用 HTTP 的情况下，字符编码是作为文本媒体类型的 Content-Type 头的一部分传送的。注意，如果 servlet 未指定内容类型，则字符编码不能通过 HTTP 头传送；但是，它仍然用于编码通过 servlet 响应的 writer 编写的文本。 所以我们需要用如下两行代码设置12response.setCharacterEncoding("utf-8");response.setHeader("Content-type", "text/html;charset=utf-8"); 作用是先设置字符集编码为utf-8,然后添加响应头Content-type值为text/html;charset=utf-8,告诉浏览器以utf-8解码.通过查看servlet的api可以知道,setCharacterEncoding(&quot;utf-8&quot;);这个方法需要在响应数据前或者response.getWriter();方法被调用之前调用. 实际上:上面的两行代码相当于response.setContentType(&quot;text/html;charset=utf-8&quot;);这一行代码.作用是一样的. 总结确定页面设置的是UTF-8以及配置了Tomcat的Server.xml文件中的编码后.在Servlet中的doPost方法中,我们插入两行以下代码.12345// 用于对请求数据解码request.setCharacterEncoding("UTF-8");// 用于对响应数据编码并通知浏览器以该字符集对响应解码.response.setContentType("text/html;charset=utf-8"); 而doGet方法只要插入response.setContentType(&quot;text/html;charset=utf-8&quot;);这一句就行.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>字符集</tag>
        <tag>Servlet</tag>
        <tag>字符编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初始化Servlet时配置Log4j, 并将日志保存在磁盘上.]]></title>
    <url>%2F2016%2F03%2F17%2Fconfiguration-log4j-with-servlet-init%2F</url>
    <content type="text"><![CDATA[通过Servlet初始化参数配置Log4j, 并将日志保存在磁盘上. 新建Servlet并配置启动参数新建一个Servlet: log4jInit.java, 建立完之后,前往web.xml文件找到配置项, 添加初始化名和参数值.123456789101112131415&lt;servlet&gt; &lt;display-name&gt;Log4jInit&lt;/display-name&gt; &lt;servlet-name&gt;Log4jInit&lt;/servlet-name&gt; &lt;servlet-class&gt;com.xxxx.util.Log4jInit&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!-- 初始化参数名. --&gt; &lt;param-name&gt;log4j&lt;/param-name&gt; &lt;!-- 配置log4j.properties的位置(该路径为项目部署后的路径) --&gt; &lt;param-value&gt;WEB-INF/classes/log4j.properties&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; 回到Servlet的init()方法中配置log4j12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.xxxx.util;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import org.apache.log4j.PropertyConfigurator;public class Log4jInit extends HttpServlet &#123; public void init(ServletConfig config) throws ServletException &#123; /** * 1. 获取项目磁盘上的真实(物理)路径. * * 地址类似于: E:\Program\Eclipse\workspace\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\wtpwebapps\你的项目名\ * (以路径分隔符结尾, windows为\ linux为/) */ String projectRealPath = getServletContext().getRealPath("/"); /** * 2. 在JVM系统中设置一个全局变量. * 设置后我们可以在log4j.properties文件中以$&#123;projectRealPath&#125;这样的形式来引用项目真实路径. * 这样子设置, 我们可以用来把日志动态保存到硬盘的某一处。 * 该方法详情见: http://blog.csdn.net/yong199105140/article/details/8425454 */ System.setProperty("projectRealPath", projectRealPath); /** * 3. 根据指定的InitParameter获取我们在web.xml配置的InitParameter参数值. * 也就是获取我们配置在web.xml中配置的log4j.properties的文件路径(WEB-INF/classes/log4j.properties). * * 也可以用getServletContext().getInitParameter("log4j");来获取. * 与这种方式的区别是, config.getInitParameter("log4j");获取的是当前Servlet中的. * * 而getServletContext().getInitParameter("log4j"); * 是在整个上下文中获取(可以理解为配置在web.xml中的所有Servlet的配置中获取) */ String log4jPropertiesFilePath = config.getInitParameter("log4j"); /** * 4. 如果获取到配置在servlet初始化参数中的log4j.properties的文件路径. * 我们则用Log4j提供的方法进行配置. */ if (log4jPropertiesFilePath != null) &#123; PropertyConfigurator.configure(projectRealPath + log4jPropertiesFilePath); &#125; &#125;&#125; log4j.properties中引用项目路径.${projectRealPath}/log/logFile.log代表我们将log文件生成在项目所在的目录里面,这也是我们在Servlet中通过System.setProperty(&quot;projectRealPath&quot;, projectRealPath); //设置的一个系统属性.1234567891011121314log4j.rootLogger=debug,stdout,Dlog4j.appender.stdout = org.apache.log4j.ConsoleAppender log4j.appender.stdout.Target = System.out log4j.appender.stdout.layout = org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern = [%-5p] [%d&#123;yyyy-MM-dd HH\:mm\:ss&#125;] [method\:%l]%n%m%n ### 用于将日志保存在磁盘上.log4j.appender.D = org.apache.log4j.DailyRollingFileAppender # 日志的记录周期为每天保存一次。log4j.appender.D.File =$&#123;projectRealPath&#125;/log/logFile.log # 日志保存的路径。log4j.appender.D.Append = truelog4j.appender.D.Threshold = DEBUG log4j.appender.D.layout = org.apache.log4j.PatternLayout log4j.appender.D.layout.ConversionPattern=[%-5p] [%d&#123;yyyy-MM-dd HH\:mm\:ss&#125;] [method\:%l]%n%m%n]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
        <tag>Log4j</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用JsonP进行跨域请求]]></title>
    <url>%2F2016%2F03%2F16%2FCross-Domain-Request-Via-Jsonp%2F</url>
    <content type="text"><![CDATA[以前有一个使用Jquery的$.post(…);来发请求想加载其他网站数据的想法，但是弹出如下错误： XMLHttpRequest cannot load http://s.music.163.com/search/get/?type=1&amp;filterDj=true&amp;s=%E7%88%B1%E5%B0%B1%E7%88%B1%E4%BA%86&amp;limit=3&amp;offset=0. No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘null’ is therefore not allowed access. 那时候还不知道这个是什么问题, 搜索了下才知道是跨域请求的问题. 后来一直心里记挂着这个事. 于是今天在闲暇之余去了解了一下. 本文会对以Jsonp方式进行的跨域请求解决办法进行说明. 学习过程中参考的网页链接, 下文的一些说明也有引用自下方链接的网页. 什么是JS跨域访问？(基本的了解)https://www.zhihu.com/question/26376773/answer/32736193 跨域与跨域访问.(跨域请求问题的出现及解决过程)http://blog.csdn.net/notechsolution/article/details/50394391 说说JSON和JSONP，也许你会豁然开朗，含jQuery用例.(推荐此文, 通俗易懂.)http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html Jsonp-维基百科(相关介绍及原理说明)https://zh.wikipedia.org/wiki/JSONP 跨域请求是什么?嗯, 跨域请求简单的来说就是指:服务器网页A在请求B服务器网页上的资源数据时, 那么当协议, 域名, 端口号三者其一有不同时, 那么就会出现跨域请求的问题.浏览器会检查服务器B的HTTP头(HEAD请求)，如果Access-Control-Allow-Origin中有A，或者是通配符*，浏览器就会允许跨域。例如: a.baidu.com访问b.baidu.com 是跨域a.baidu.com:8080访问a.baidu.com:80 是跨域http://a.baidu.com访问https://a.baidu.com 是跨域 还有一点比较重要，限制跨域是浏览器的行为，而不是JS的行为。 为什么浏览器要限制跨域访问呢？参见：http://blog.csdn.net/notechsolution/article/details/50394391#t1 为什么要跨域以及跨域的作用是什么？参见：http://blog.csdn.net/notechsolution/article/details/50394391#t2 通过上面的知识我们知道了跨域的问题根本以及跨域的作用以及何时需要跨域！下面就是真正面对面接触了。 Jsonp跨域的原理是什么以及如何进行跨域？这里本人粗浅的说一下本人的理解, 具体的大家可以去Jsonp-维基百科这里了解.以前我在听别人说跨域请求的时候, 大概只是在脑海里知道a站访问b站有时候会出现安全问题, 而无法获取到数据什么的.随后在引用其他其他js文件的时候发现, 为什么这样子就可以拿到其他网站的资源?1&lt;script type=&quot;text/Javascript&quot; src=&quot;http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt; 那时候就隐约觉得这个事有点蹊跷, 不过那时候还不知道是跟跨域有关系.当在维基百科上看到原理的介绍时, 才恍然大悟.原来Jsonp就是基于的这个实现的.现在知道一些带有src属性的标签都可以不受浏览器的约束而获取到其他网站的数据. 以代码的方式来说一下原理.首先我们知道, 如果使用script标签的src属性引用了一个js文件, 那么不管这个js文件在哪里都是可以执行的, 为什么会执行, 因为他返回了一个Javascript文本或者Javascript对象. 例如假设在一个服务器上的 http://xxx.com/test.js 内容是: 1alert(&quot;Test JS Execute!&quot;); 123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Test&lt;/title&gt; &lt;script type=&quot;text/Javascript&quot; src=&quot;http://xxx.com/test.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 那么当你引用JS文件之后，在也面加载的时候，页面会弹出Test JS Execute!。用这个举例子就是想说明一个事， 那就是script标签可以加载远程的js代码并且执行!基于这个原理, jsonp的实现方式是: 通过远程的服务器返回一个函数调用的代码来调用我们事先定义的函数. 这里先建立一个1.html文件写上这段代码, 定义一个testFunction这个函数. 12345&lt;script type=&quot;text/Javascript&quot;&gt; var testFunction = function (data) &#123; console.log(data); &#125;;&lt;/script&gt; 定义这个函数之后, 我可以通过 testFunction(data); 来调用执行它的是吧?那么OK, 我让远程是文件返回一个这样的函数调用代码过来, 然后让他加载到script标签里面这样不就可以调用这个函数了么? 而这个函数中的data就是我们希望跨域传过来的json数据. 所以我在服务端把这个json数据准备好, 然后拼接成调用js方法的代码返回给页面不就可以了么? 例如我向页面输出这样的内容: 12345String json = &quot;&#123;\&quot;result\&quot;:\&quot;测试JSONP&quot;&#125;&quot;;// 输出到页面为: &#123;&quot;result&quot;:&quot;测试JSONP&quot;&#125;response.getWriter().writer(&quot;testFunction(&quot; + json + &quot;);&quot;);// 输出到页面为: testFunction(&#123;&quot;result&quot;:&quot;测试JSONP&quot;&#125;); 这样子之后, 我再把1.html改成这样子 123456789101112131415&lt;script type=&quot;text/Javascript&quot;&gt; // 定义一个函数 var testFunction = function (data)&#123; console.log(data); &#125;; // 生成script标签来调用上面的函数. var url =&quot;http://xxx.com/TestFunctionServlet&quot;; var script = document.createElement(&apos;script&apos;); script.setAttribute(&apos;src&apos;, url); // 把script标签加入head标签.这个时候就可以调用我们上面定义的testFunction函数了. document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script);&lt;/script&gt; 上面的代码会生成一个script标签. 1&lt;script type=&quot;text/Javascript&quot; src=&quot;http://xxx.com/TestFunctionServlet&quot;&gt;&lt;/script&gt; 这个script标签执行之后, 就会调用我们定义的函数. 这就是跨域请求的原理和基本实现. JQuery给我们提供了$.ajxx();这个方法, 但是他和jsonp是2个东西, 但是原理也是和这个一样的.只是他在内部做了封装处理, 还为了提供了很多方便的地方.具体参考: http://www.cnblogs.com/dowinning/archive/2012/04/19/json-jsonp-jquery.html 这个文章, 在文章结尾上方说明了JQuery的代码实现. 另外还有一点就是, 大家可能会问, 服务器端那里给我写数据的时候他怎么就知道我页面定义的函数名字是什么?这个就需要用到查到字符串, 我们可以在url后面加上callback这个查询字符串然后写上你的本地函数名, 传递到服务器服务器解析出来, 写出的时候再传递给页面, 这样就是动态的过程了. 大家如果观察过别人网站的url地址时是可以发现callback这个东西的.例如网易云这个URL我加上callback, 随便给一个函数名字.大家可以访问 http://s.music.163.com/search/get/?type=1&amp;filterDj=true&amp;s=%C2%A0%E7%88%B1%E5%B0%B1%E7%88%B1%E4%BA%86&amp;limit=3&amp;offset=0&amp;callback=testJsonp他在下发数据的时候就会加上这个函数名. 点开这个网页看看就可以看到testJsonp(jsonObj)的括号里面套了一个json对象.如果看到的json是乱七八糟的网页源文件, 那么谷歌浏览器可以安装一个jsonview插件, 这样就显示了格式化之后的json. 本文针对jsonp方式的跨域请求进行简单的说明, 大家也可以去研究下JQuery提供的解决方案，理解了这个，那个就很容易了。最后，跨域通信手段大概有：jsonp，document.domain，window.name，hash传值，possMessage，Access-Control-Allow-Origin看起来方法挺多，但是应用场景都有一定要求，按需使用吧。]]></content>
      <categories>
        <category>跨域请求</category>
      </categories>
      <tags>
        <tag>跨域请求</tag>
        <tag>Javascript</tag>
        <tag>JsonP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS属性访问表达式之对象访问属性点方式与中括号方式的区别]]></title>
    <url>%2F2016%2F03%2F14%2Fjs-field-access-expression%2F</url>
    <content type="text"><![CDATA[js中属性访问表达式,通过表达式访问对象或者数组中的属性.本文只讲解对象部分. js提供了2种语法: expression.identifier // person.name 这种写法是一个表达式后面加上一个点再加上标识符. 表达式代表对象,标识符表示要访问属性的名称. expression[expression] // person[“name”] 该方法由一个表达式后跟随一个中括号,并且中括号里面也算一个表达式. 这种写法一般适用于对象和数组.第二个表达用于指定要访问的属性名或者数组的索引. 区别: 一般点后面跟上的是对象的属性名标识符,注意是标识符而不是字符串.例如:person.name //正确person.”name” // 语法错误 中括号内跟的是属性名的字符串表示方式.person[“name”]// 正确person[name]// 返回undefined 处理机制: 不论方式1或方式2,在点和中括号之前的表达式也会进行计算.意思是说如果对象或者数组为undefined或者为null,那么就抛出类型错误异常.因为一个是未定义一个是空都无法包含属性. 如果使用方式1也点访问属性,那么则直接在对象中查找点后标识符对应的属性,并返回该值.如果使用方式2以中括号访问,那么先把中括号内的变量转换成为字符串再再对象中查找.(关于中括号方式下面我会继续说明) 代码说明Code112345678910&lt;script type="text/Javascript"&gt; var person = &#123;name:"Tom"&#125;; // 对象Person console.log(person.name); // Tom,直接用name标识符去对象中找对应的属性找到了就返回(上面已经提过了.) console.log(person."name"); // 语法错误. console.log(person["name"]; // Tom console.log(person[name]); // undefined&lt;/script&gt; 代码1需要说明处:console.log(person[&quot;name&quot;];// 输出结果:Tom这里还需要说明一个过程.js再创建对象的时候,实际上var person = {name:&quot;Tom&quot;}和var person = {&quot;name&quot;:&quot;Tom&quot;}是相等的.也就是说你不加双引号,他也会自己给加上.所以他根据中括号中的name字符串去对象中自然就可以找到对应的值. console.log(person[name]);// 输出结果:undefined为什么会输出为undefined?首先他先计算变量name的值尝试将它转成String类型.但是我们并没有定义name这个变量.所以中括号内的表达式计算结果为undefined,再去对象中找undefined显然是找不到的所以最终输出为undefined. Code21234567&lt;script type="text/Javascript"&gt; var person = &#123;name:"Tom"&#125;; // 对象Person var namestr = "name"; console.log(person.nameStr); // undefined console.log(person[nameStr]); // Tom&lt;/script&gt; 代码2需要说明的地方:console.log(person.nameStr);// 输出结果:undefined为什么会是undefined?这很好解释,他直接去对象中找nameStr属性,对象中并没有这个属性,自然就为undefined. console.log(person[nameStr]);这里可以输出Tom则是因为nameStr自动转换成了”name”这个字符串.这点上面提到了.中括号里面的算是一个表达式,如果是一个变量,那么会自动转成字符串类型.所以自然可以取到属性值. 总结以点的方式访问,那么一般都是写属性名.而以中括号的方式访问,需要把属性名用双引号括起来.如果中括号内是一个变量,那么会自动把变量转成字符串,再去对象中查找. 本文参考:《Javascript权威指南》4.4节:属性访问表达式.]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Date型数据转成json数据时出现的问题]]></title>
    <url>%2F2016%2F02%2F17%2Fquestion-of-date-data-transform-to-json-data%2F</url>
    <content type="text"><![CDATA[今天在项目中遇到2个问题,关于从数据库读取日期类型数据和将Date型数据解析成JSON. 问题1:在页面上希望显示的日期格式为:yyyy-MM-dd HH:mm:ss,而读取数据库数据时返回的是英文格式的日期时间. 问题2:需要传递json数据给页面.而在解析该Date类型的属性时,输出的json字符串却类似于这样显示为时间戳.1&#123;"nanos":0,"time":-27076233600000,"minutes":0,"seconds":0,"hours":0,"month":11,"timezoneOffset":-480,"year":-789,"day":5,"date":22&#125; 很明显这不是我们想要的. 问题1首先在读取数据库时就返回英文格式日期时间,所以首先得解决该问题.本人数据库里的字段类型是Tiemstamp然后我尝试将javabean属性类型改为下面两种类型 javabean的属性类型改为java.util.date, 进行数据库读取时,输出格式为英文的日期格式. javabean的属性类型改为java.sql.date, 进行数据读取时,同样输出为英文的日期格式. 这两种方式都尝试过,但返回的数据依然不是我们想要的格式. 解决方案:首先将Javabean属性的类型改为java.sql.Timestamp12import java.sql.Timestamp;private Timestamp createTime; 接着在框架的返回值类型那里同样映射为Timestamp.以mybatis为例,在resultMap中增加jdbcType=&quot;TIMESTAMP&quot;12&lt;result column="message_createtime" property="createTime" jdbcType="TIMESTAMP" /&gt; 这样子数据库读取后就会返回中文的日期格式. 问题2现在问题1解决了,以为在解析json时就会顺其而然的解析成功了.但是却将那个其中createTime转换成了时间戳的格式.这样的格式在页面上显示肯定是不行的.问题出在json解析这一块,于是我想着是不是现在用的json解析jar包的问题呢?第一次用的gson解析,第二次换成了json-lib来解析,发现还是有这样的问题. 解决方案:使用Json-lib解决于是就觉得这可能是个通病,打开谷歌一搜,看到如下如下文章(感谢该博主分享):JSONObject转换JSON–将Date转换为指定格式 照做一遍问题解决了. 这是Json-lib提供的一个转换器接口,实现他之后,我们根据自己的需要进行转换. 第一步: 12345678910111213141516171819202122232425262728293031323334353637public class JsonDateValueProcessor implements JsonValueProcessor &#123; // 转换的格式 private String format ="yyyy-MM-dd HH:mm:ss"; public JsonDateValueProcessor() &#123; super(); &#125; public JsonDateValueProcessor(String format) &#123; super(); this.format = format; &#125; @Override public Object processArrayValue(Object paramObject, JsonConfig paramJsonConfig) &#123; return process(paramObject); &#125; @Override public Object processObjectValue(String paramString, Object paramObject, JsonConfig paramJsonConfig) &#123; return process(paramObject); &#125; // 定义方法自己进行自定义处理. private Object process(Object value)&#123; if(value instanceof Date)&#123; SimpleDateFormat sdf = new SimpleDateFormat(format, Locale.CHINA); return sdf.format(value); &#125; return value == null ? "" : value.toString(); &#125; &#125; 第二步 在转换成json字符串之前进行配置. 12345// 在使用JSONObject之前创建JsonConfig对象JsonConfig jsonConfig = new JsonConfig(); //注册我们自定义的date转换器jsonConfig.registerJsonValueProcessor(Date.class, new JsonDateValueProcessor()); 第三步 在使用JSONObject时,添加JsonConfig对象,例如我在把这个jsonMap转换为json时,就可以在后面加上jsonConfig对象. 1JSONObject.fromObject(jsonMap, jsonConfig); 使用Gson解决.在创建Gson对象的使用1Gson gson = new GsonBuilder().setDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;).create(); 这样输出的数据就是yyyy-MM-dd HH:mm:ss我们看上有好感的格式了.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Json</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux创建指定文件，文件夹，网页url地址快捷方式]]></title>
    <url>%2F2016%2F01%2F07%2Fcreate-shortcuts-in-linux%2F</url>
    <content type="text"><![CDATA[创建指定文件快捷方式命令：ln -s 目标文件路径 link_name可以通过man ln详细看一下例如：ln -s /opt/eclipse/eclipse /home/123fs/desktop 创建指定文件夹快捷方式命令：ln -s 目标文件夹路径 link_name同上。 创建指定网页URL地址快捷方式 进入到你想创建快捷方式的目录执行vim xxxx.url 按i进入编辑模式输入以下内容 12[InternetShortcut]URL=Http://Google.CoM 按ESC退到命令模式:wq！保存退出。 右键创建的文件，打开方式选择浏览器即可。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux命令</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis插入记录后获取主键id]]></title>
    <url>%2F2015%2F12%2F23%2FMybatis-Get-DataBase-Primary-Key%2F</url>
    <content type="text"><![CDATA[Oracle数据库Oracle数据库插入记录后获取id主键,首先建立一个序列（就是每次查询会自动增加值的绝不重复的对象，比如每次加1或每次加10）语法：1234CREATE SEQUENCE 序列名[INCREMENT BY n] --每次加几[START WITH n] --序列从几开始[&#123;MAXVALUE/ MINVALUE n|NOMAXVALUE&#125;] --最小值、最大值的限制,或者没有最大值. 比如CREATE SEQUENCE s_test start with 1 increment by 1;就是建立了一个从1开始每次加1的序列.访问序列时,用序列名称.nextval的语法。 而在实际代码中,我们可以通过使用SelectKey来获取到id,selectKey会自动把数据库的主键id赋值给对应javabean的id属性.在更新和插入的时候,都是可以通过SelectKey来获取插入的id主键. 注解版的方式配置4个属性: statement在这里用select语句来查询下一个id主键值. before就是值在insert语句之前执行 keyProperty=&quot;id&quot;注意:这个配置的是对应数据库主键javabean的属性名,而不是数据库的字段名! resultType 返回的主键id值的类型,最好是和javabean的id属性类型对应. 123@SelectKey(statement="select user_seq.nextval from dual", before=true, keyProperty="id", resultType=Integer.class)@Insert("insert into users (id,name) values (#&#123;id&#125;,#&#123;name&#125;)")void saveUser(User user); 配置文件方式配置3个属性: keyProperty=&quot;id&quot;注意:这个配置的是对应数据库主键javabean的属性名,而不是数据库的字段名! 这里的order=&quot;BEFORE&quot;属性设置为BEFORE就是和注解版的before=true是一个意思. resultType 返回的主键id值的类型,最好是和javabean的id属性类型对应. 123456&lt;insert id="saveUser" parameterType="com.xxx.entities.User"&gt; insert into users (id,name) values (#&#123;id&#125;,#&#123;name&#125;) &lt;selectKey keyProperty="id" order="BEFORE" resultType="Integer"&gt; select user_seq.nextval from dual &lt;/selectKey&gt;&lt;/insert&gt; MySql数据库由于MySql数据库是支持自动生成主键的,所以我们只需要设置一些属性就可以获取到主键了. 注解版的方式 123@Insert("INSERT INTO Employees (name, age, birth, registerTime, salary) " + "VALUES (#&#123;name&#125;, #&#123;age&#125;,#&#123;birth&#125;,#&#123;registerTime&#125;, #&#123;salary&#125;)")void addEmployee(Employee employee); 配置文件方式配置2个属性: keyProperty=&quot;id&quot;注意:这个配置的是对应数据库主键javabean的属性名,而不是数据库的字段名! useGeneratedKeys=&quot;true&quot; 使用自动生成key设置为true 注意:这个配置的是对应数据库主键javabean的属性名,而不是数据库的字段名! 123456&lt;insert id="addEmployee" parameterType="Employee" keyProperty="id" useGeneratedKeys="true"&gt; INSERT INTO Employees (name, age, birth, registerTime,salary) VALUES (#&#123;name&#125;, #&#123;age&#125;, #&#123;birth&#125;,#&#123;registerTime&#125;, #&#123;salary&#125;)&lt;/insert&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之静态代理模式详解]]></title>
    <url>%2F2015%2F09%2F20%2FStatic%20agent%20of%20Java%20design%20patterns%2F</url>
    <content type="text"><![CDATA[静态代理设计思想 总体思想,通过传递一个被代理类的对象到代理类构造器中的参数,来决定代理类去代理哪个被代理类.代理一个被代理类就是把被代理类的对象传到 代理类的构造器中,然后去调用已经实现接口中的哪些方法. 需要一个接口,定义一些方法.然后有好几个被代理类去实现接口中的这些方法,接着有一个代理类也去实现这些方法,只不过代理类的实现过程是直接调用被代理类中实现好的方法. 举个很形象的例子,就比如你要去XX品牌专卖店买个东西,然后当你和店员谈好价格准备拿货时老板说哎呀我这里暂时没货,明天我去厂子里给你拿一个之类的话.老板就好比代理类,具体生产某品牌的商品的厂子就好比是个被代理类. 接口的作用,接口一直都是起到一个定义的作用!就是定义一些必须的操作,让具体的类去实现它.这就像是说上司给你安排任务,具体怎么做他不管,他关心的是你有没有完成这个任务. 具体看下面的代码和注释,举了个故事情景的例子方便理解. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/* * 第1步,假设有个鼠标的生厂商,然后有个客户要买个鼠标.但是生厂商只负责生产鼠标 * 不知道客户具体要买什么鼠标,所以这里定义个接口. */// 这个接口是鼠标生产商interface MouseProducers &#123; // 然后他具有的功能就是生产鼠标. void produceMouse();&#125;/* * 第2步,有两个可以生产鼠标的鼠标生产商. */// 第一个实现类是: 生产雷蛇鼠标的厂商class RazerMouseProducers implements MouseProducers &#123; @Override public void produceMouse() &#123; System.out.println("我是雷蛇鼠标生产商."); &#125;&#125;// 第二个实现类是: 生产罗技鼠标的厂商class LogitMouseProducers implements MouseProducers &#123; @Override public void produceMouse() &#123; System.out.println("我是罗技鼠标生产商."); &#125;&#125;/* * 第3步,某某鼠标专卖店,这个专卖店呢他自己不会生产鼠标,但是他知道在哪可以帮你拿到货. * 你要买雷蛇的他就去雷蛇鼠标生产商帮你拿货,你要买罗技的他就去罗技生产商帮你拿货. * 就算你以后想买个别的鼠标,他也可以帮你拿到货.(只要我们提供MouseProducers接口的实现类, 他都可以代理帮你拿货) *//* * 1. 定义一个鼠标商店类,也让他实现MouseProducers接口,这个MouseStore类就称为代理类. * 为什么要让他实现呢? 你想啊,他是卖鼠标的, 他得假装他会生产鼠标是吧? * 所以说他要实现这个接口,而且还要接口中的方法. * * 2. 方法实现完了,我们还需要写个构造器.而且还是有参数的. * * 2.1 为什么要是有参数的? * 作为卖鼠标的商店,客户得告诉他要买什么鼠标,他才能去拿货是不是. * 所以我们写个带参数的构造器, 让参数来告诉他要什么样的鼠标. * * 2.2 要有什么参数? 雷蛇类的鼠标还是罗技类的鼠标呢? * 啪! 都不是, 因为你想啊, 你要是写死了的话, 那我们来假设下, 如果来2个客户, 一个要雷蛇的, 一个要罗技的. * 你能告诉他们你家只卖一种鼠标吗? 所以说我们要写MouseProducers这个接口的实例. * 然后等客户要买啥鼠标, 我们再new一个这个接口的实现类的对象给他.(这个就是面向对象中美妙的多态性啦!) */class MouseStore implements MouseProducers &#123; private MouseProducers mouseProducers; // 这里用接口来定义对象是因为传递过来的对象是其实现类的其中一个. public MouseStore(MouseProducers mouseProducers) &#123; this.mouseProducers = mouseProducers; &#125; @Override public void produceMouse() &#123; // 这时候再去调用接口实现类中的方法就可以了. mouseProducers.produceMouse(); &#125;&#125;public class StaticProxyModelTest &#123; public static void main(String[] args) &#123; // 假设2个客户 第一个买雷蛇 第二个买罗技 MouseProducers mp_1 = new RazerMouseProducers(); MouseStore mouseStore_1 = new MouseStore(mp_1); mouseStore_1.produceMouse(); MouseProducers mp_2 = new LogitMouseProducers(); MouseStore mouseStore_2 = new MouseStore(mp_2); mouseStore_2.produceMouse(); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
        <tag>静态代理</tag>
      </tags>
  </entry>
</search>
